// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: leveldbr.proto
// Protobuf C++ Version: 5.26.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_leveldbr_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_leveldbr_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION != 5026001
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_leveldbr_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_leveldbr_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_leveldbr_2eproto;
namespace remote {
class CloseReply;
struct CloseReplyDefaultTypeInternal;
extern CloseReplyDefaultTypeInternal _CloseReply_default_instance_;
class CloseRequest;
struct CloseRequestDefaultTypeInternal;
extern CloseRequestDefaultTypeInternal _CloseRequest_default_instance_;
class GetReply;
struct GetReplyDefaultTypeInternal;
extern GetReplyDefaultTypeInternal _GetReply_default_instance_;
class GetRequest;
struct GetRequestDefaultTypeInternal;
extern GetRequestDefaultTypeInternal _GetRequest_default_instance_;
class InMessage;
struct InMessageDefaultTypeInternal;
extern InMessageDefaultTypeInternal _InMessage_default_instance_;
class KeyValue;
struct KeyValueDefaultTypeInternal;
extern KeyValueDefaultTypeInternal _KeyValue_default_instance_;
class LookupNextReply;
struct LookupNextReplyDefaultTypeInternal;
extern LookupNextReplyDefaultTypeInternal _LookupNextReply_default_instance_;
class LookupNextRequest;
struct LookupNextRequestDefaultTypeInternal;
extern LookupNextRequestDefaultTypeInternal _LookupNextRequest_default_instance_;
class LookupReply;
struct LookupReplyDefaultTypeInternal;
extern LookupReplyDefaultTypeInternal _LookupReply_default_instance_;
class LookupRequest;
struct LookupRequestDefaultTypeInternal;
extern LookupRequestDefaultTypeInternal _LookupRequest_default_instance_;
class OpenReply;
struct OpenReplyDefaultTypeInternal;
extern OpenReplyDefaultTypeInternal _OpenReply_default_instance_;
class OpenRequest;
struct OpenRequestDefaultTypeInternal;
extern OpenRequestDefaultTypeInternal _OpenRequest_default_instance_;
class OutMessage;
struct OutMessageDefaultTypeInternal;
extern OutMessageDefaultTypeInternal _OutMessage_default_instance_;
class PutReply;
struct PutReplyDefaultTypeInternal;
extern PutReplyDefaultTypeInternal _PutReply_default_instance_;
class PutRequest;
struct PutRequestDefaultTypeInternal;
extern PutRequestDefaultTypeInternal _PutRequest_default_instance_;
class RemoveReply;
struct RemoveReplyDefaultTypeInternal;
extern RemoveReplyDefaultTypeInternal _RemoveReply_default_instance_;
class RemoveRequest;
struct RemoveRequestDefaultTypeInternal;
extern RemoveRequestDefaultTypeInternal _RemoveRequest_default_instance_;
class SnapshotReply;
struct SnapshotReplyDefaultTypeInternal;
extern SnapshotReplyDefaultTypeInternal _SnapshotReply_default_instance_;
class SnapshotRequest;
struct SnapshotRequestDefaultTypeInternal;
extern SnapshotRequestDefaultTypeInternal _SnapshotRequest_default_instance_;
class WriteReply;
struct WriteReplyDefaultTypeInternal;
extern WriteReplyDefaultTypeInternal _WriteReply_default_instance_;
class WriteRequest;
struct WriteRequestDefaultTypeInternal;
extern WriteRequestDefaultTypeInternal _WriteRequest_default_instance_;
}  // namespace remote
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace remote {

// ===================================================================


// -------------------------------------------------------------------

class WriteReply final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:remote.WriteReply) */ {
 public:
  inline WriteReply() : WriteReply(nullptr) {}
  ~WriteReply() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR WriteReply(
      ::google::protobuf::internal::ConstantInitialized);

  inline WriteReply(const WriteReply& from) : WriteReply(nullptr, from) {}
  inline WriteReply(WriteReply&& from) noexcept
      : WriteReply(nullptr, std::move(from)) {}
  inline WriteReply& operator=(const WriteReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline WriteReply& operator=(WriteReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WriteReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const WriteReply* internal_default_instance() {
    return reinterpret_cast<const WriteReply*>(
        &_WriteReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(WriteReply& a, WriteReply& b) { a.Swap(&b); }
  inline void Swap(WriteReply* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WriteReply* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WriteReply* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<WriteReply>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const WriteReply& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const WriteReply& from) { WriteReply::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(WriteReply* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "remote.WriteReply"; }

 protected:
  explicit WriteReply(::google::protobuf::Arena* arena);
  WriteReply(::google::protobuf::Arena* arena, const WriteReply& from);
  WriteReply(::google::protobuf::Arena* arena, WriteReply&& from) noexcept
      : WriteReply(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kErrorFieldNumber = 1,
  };
  // string error = 1;
  void clear_error() ;
  const std::string& error() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_error(Arg_&& arg, Args_... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* value);

  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(
      const std::string& value);
  std::string* _internal_mutable_error();

  public:
  // @@protoc_insertion_point(class_scope:remote.WriteReply)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      31, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr error_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_leveldbr_2eproto;
};
// -------------------------------------------------------------------

class SnapshotRequest final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:remote.SnapshotRequest) */ {
 public:
  inline SnapshotRequest() : SnapshotRequest(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SnapshotRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline SnapshotRequest(const SnapshotRequest& from) : SnapshotRequest(nullptr, from) {}
  inline SnapshotRequest(SnapshotRequest&& from) noexcept
      : SnapshotRequest(nullptr, std::move(from)) {}
  inline SnapshotRequest& operator=(const SnapshotRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SnapshotRequest& operator=(SnapshotRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SnapshotRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SnapshotRequest* internal_default_instance() {
    return reinterpret_cast<const SnapshotRequest*>(
        &_SnapshotRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 19;
  friend void swap(SnapshotRequest& a, SnapshotRequest& b) { a.Swap(&b); }
  inline void Swap(SnapshotRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SnapshotRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SnapshotRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<SnapshotRequest>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SnapshotRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SnapshotRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "remote.SnapshotRequest"; }

 protected:
  explicit SnapshotRequest(::google::protobuf::Arena* arena);
  SnapshotRequest(::google::protobuf::Arena* arena, const SnapshotRequest& from);
  SnapshotRequest(::google::protobuf::Arena* arena, SnapshotRequest&& from) noexcept
      : SnapshotRequest(arena) {
    *this = ::std::move(from);
  }

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:remote.SnapshotRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_leveldbr_2eproto;
};
// -------------------------------------------------------------------

class SnapshotReply final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:remote.SnapshotReply) */ {
 public:
  inline SnapshotReply() : SnapshotReply(nullptr) {}
  ~SnapshotReply() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SnapshotReply(
      ::google::protobuf::internal::ConstantInitialized);

  inline SnapshotReply(const SnapshotReply& from) : SnapshotReply(nullptr, from) {}
  inline SnapshotReply(SnapshotReply&& from) noexcept
      : SnapshotReply(nullptr, std::move(from)) {}
  inline SnapshotReply& operator=(const SnapshotReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline SnapshotReply& operator=(SnapshotReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SnapshotReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const SnapshotReply* internal_default_instance() {
    return reinterpret_cast<const SnapshotReply*>(
        &_SnapshotReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 20;
  friend void swap(SnapshotReply& a, SnapshotReply& b) { a.Swap(&b); }
  inline void Swap(SnapshotReply* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SnapshotReply* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SnapshotReply* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<SnapshotReply>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SnapshotReply& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SnapshotReply& from) { SnapshotReply::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SnapshotReply* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "remote.SnapshotReply"; }

 protected:
  explicit SnapshotReply(::google::protobuf::Arena* arena);
  SnapshotReply(::google::protobuf::Arena* arena, const SnapshotReply& from);
  SnapshotReply(::google::protobuf::Arena* arena, SnapshotReply&& from) noexcept
      : SnapshotReply(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kErrorFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // string error = 2;
  void clear_error() ;
  const std::string& error() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_error(Arg_&& arg, Args_... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* value);

  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(
      const std::string& value);
  std::string* _internal_mutable_error();

  public:
  // uint64 id = 1;
  void clear_id() ;
  ::uint64_t id() const;
  void set_id(::uint64_t value);

  private:
  ::uint64_t _internal_id() const;
  void _internal_set_id(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:remote.SnapshotReply)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      34, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr error_;
    ::uint64_t id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_leveldbr_2eproto;
};
// -------------------------------------------------------------------

class RemoveRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:remote.RemoveRequest) */ {
 public:
  inline RemoveRequest() : RemoveRequest(nullptr) {}
  ~RemoveRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RemoveRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline RemoveRequest(const RemoveRequest& from) : RemoveRequest(nullptr, from) {}
  inline RemoveRequest(RemoveRequest&& from) noexcept
      : RemoveRequest(nullptr, std::move(from)) {}
  inline RemoveRequest& operator=(const RemoveRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoveRequest& operator=(RemoveRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemoveRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemoveRequest* internal_default_instance() {
    return reinterpret_cast<const RemoveRequest*>(
        &_RemoveRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(RemoveRequest& a, RemoveRequest& b) { a.Swap(&b); }
  inline void Swap(RemoveRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoveRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemoveRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<RemoveRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RemoveRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RemoveRequest& from) { RemoveRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RemoveRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "remote.RemoveRequest"; }

 protected:
  explicit RemoveRequest(::google::protobuf::Arena* arena);
  RemoveRequest(::google::protobuf::Arena* arena, const RemoveRequest& from);
  RemoveRequest(::google::protobuf::Arena* arena, RemoveRequest&& from) noexcept
      : RemoveRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDbnameFieldNumber = 1,
  };
  // string dbname = 1;
  void clear_dbname() ;
  const std::string& dbname() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_dbname(Arg_&& arg, Args_... args);
  std::string* mutable_dbname();
  PROTOBUF_NODISCARD std::string* release_dbname();
  void set_allocated_dbname(std::string* value);

  private:
  const std::string& _internal_dbname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dbname(
      const std::string& value);
  std::string* _internal_mutable_dbname();

  public:
  // @@protoc_insertion_point(class_scope:remote.RemoveRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      35, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr dbname_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_leveldbr_2eproto;
};
// -------------------------------------------------------------------

class RemoveReply final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:remote.RemoveReply) */ {
 public:
  inline RemoveReply() : RemoveReply(nullptr) {}
  ~RemoveReply() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RemoveReply(
      ::google::protobuf::internal::ConstantInitialized);

  inline RemoveReply(const RemoveReply& from) : RemoveReply(nullptr, from) {}
  inline RemoveReply(RemoveReply&& from) noexcept
      : RemoveReply(nullptr, std::move(from)) {}
  inline RemoveReply& operator=(const RemoveReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoveReply& operator=(RemoveReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemoveReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemoveReply* internal_default_instance() {
    return reinterpret_cast<const RemoveReply*>(
        &_RemoveReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(RemoveReply& a, RemoveReply& b) { a.Swap(&b); }
  inline void Swap(RemoveReply* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoveReply* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemoveReply* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<RemoveReply>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RemoveReply& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RemoveReply& from) { RemoveReply::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RemoveReply* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "remote.RemoveReply"; }

 protected:
  explicit RemoveReply(::google::protobuf::Arena* arena);
  RemoveReply(::google::protobuf::Arena* arena, const RemoveReply& from);
  RemoveReply(::google::protobuf::Arena* arena, RemoveReply&& from) noexcept
      : RemoveReply(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kErrorFieldNumber = 1,
  };
  // string error = 1;
  void clear_error() ;
  const std::string& error() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_error(Arg_&& arg, Args_... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* value);

  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(
      const std::string& value);
  std::string* _internal_mutable_error();

  public:
  // @@protoc_insertion_point(class_scope:remote.RemoveReply)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      32, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr error_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_leveldbr_2eproto;
};
// -------------------------------------------------------------------

class PutRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:remote.PutRequest) */ {
 public:
  inline PutRequest() : PutRequest(nullptr) {}
  ~PutRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PutRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline PutRequest(const PutRequest& from) : PutRequest(nullptr, from) {}
  inline PutRequest(PutRequest&& from) noexcept
      : PutRequest(nullptr, std::move(from)) {}
  inline PutRequest& operator=(const PutRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PutRequest& operator=(PutRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PutRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PutRequest* internal_default_instance() {
    return reinterpret_cast<const PutRequest*>(
        &_PutRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(PutRequest& a, PutRequest& b) { a.Swap(&b); }
  inline void Swap(PutRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PutRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PutRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<PutRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PutRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PutRequest& from) { PutRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PutRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "remote.PutRequest"; }

 protected:
  explicit PutRequest(::google::protobuf::Arena* arena);
  PutRequest(::google::protobuf::Arena* arena, const PutRequest& from);
  PutRequest(::google::protobuf::Arena* arena, PutRequest&& from) noexcept
      : PutRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // bytes key = 1;
  void clear_key() ;
  const std::string& key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* value);

  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(
      const std::string& value);
  std::string* _internal_mutable_key();

  public:
  // bytes value = 2;
  void clear_value() ;
  const std::string& value() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_value(Arg_&& arg, Args_... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);

  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(
      const std::string& value);
  std::string* _internal_mutable_value();

  public:
  // @@protoc_insertion_point(class_scope:remote.PutRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr key_;
    ::google::protobuf::internal::ArenaStringPtr value_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_leveldbr_2eproto;
};
// -------------------------------------------------------------------

class PutReply final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:remote.PutReply) */ {
 public:
  inline PutReply() : PutReply(nullptr) {}
  ~PutReply() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PutReply(
      ::google::protobuf::internal::ConstantInitialized);

  inline PutReply(const PutReply& from) : PutReply(nullptr, from) {}
  inline PutReply(PutReply&& from) noexcept
      : PutReply(nullptr, std::move(from)) {}
  inline PutReply& operator=(const PutReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline PutReply& operator=(PutReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PutReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const PutReply* internal_default_instance() {
    return reinterpret_cast<const PutReply*>(
        &_PutReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(PutReply& a, PutReply& b) { a.Swap(&b); }
  inline void Swap(PutReply* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PutReply* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PutReply* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<PutReply>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PutReply& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PutReply& from) { PutReply::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PutReply* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "remote.PutReply"; }

 protected:
  explicit PutReply(::google::protobuf::Arena* arena);
  PutReply(::google::protobuf::Arena* arena, const PutReply& from);
  PutReply(::google::protobuf::Arena* arena, PutReply&& from) noexcept
      : PutReply(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kErrorFieldNumber = 1,
  };
  // string error = 1;
  void clear_error() ;
  const std::string& error() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_error(Arg_&& arg, Args_... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* value);

  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(
      const std::string& value);
  std::string* _internal_mutable_error();

  public:
  // @@protoc_insertion_point(class_scope:remote.PutReply)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      29, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr error_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_leveldbr_2eproto;
};
// -------------------------------------------------------------------

class OpenRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:remote.OpenRequest) */ {
 public:
  inline OpenRequest() : OpenRequest(nullptr) {}
  ~OpenRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR OpenRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline OpenRequest(const OpenRequest& from) : OpenRequest(nullptr, from) {}
  inline OpenRequest(OpenRequest&& from) noexcept
      : OpenRequest(nullptr, std::move(from)) {}
  inline OpenRequest& operator=(const OpenRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpenRequest& operator=(OpenRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OpenRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const OpenRequest* internal_default_instance() {
    return reinterpret_cast<const OpenRequest*>(
        &_OpenRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(OpenRequest& a, OpenRequest& b) { a.Swap(&b); }
  inline void Swap(OpenRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpenRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OpenRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<OpenRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const OpenRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const OpenRequest& from) { OpenRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(OpenRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "remote.OpenRequest"; }

 protected:
  explicit OpenRequest(::google::protobuf::Arena* arena);
  OpenRequest(::google::protobuf::Arena* arena, const OpenRequest& from);
  OpenRequest(::google::protobuf::Arena* arena, OpenRequest&& from) noexcept
      : OpenRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDbnameFieldNumber = 1,
    kCreateFieldNumber = 2,
  };
  // string dbname = 1;
  void clear_dbname() ;
  const std::string& dbname() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_dbname(Arg_&& arg, Args_... args);
  std::string* mutable_dbname();
  PROTOBUF_NODISCARD std::string* release_dbname();
  void set_allocated_dbname(std::string* value);

  private:
  const std::string& _internal_dbname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dbname(
      const std::string& value);
  std::string* _internal_mutable_dbname();

  public:
  // bool create = 2;
  void clear_create() ;
  bool create() const;
  void set_create(bool value);

  private:
  bool _internal_create() const;
  void _internal_set_create(bool value);

  public:
  // @@protoc_insertion_point(class_scope:remote.OpenRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      33, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr dbname_;
    bool create_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_leveldbr_2eproto;
};
// -------------------------------------------------------------------

class OpenReply final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:remote.OpenReply) */ {
 public:
  inline OpenReply() : OpenReply(nullptr) {}
  ~OpenReply() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR OpenReply(
      ::google::protobuf::internal::ConstantInitialized);

  inline OpenReply(const OpenReply& from) : OpenReply(nullptr, from) {}
  inline OpenReply(OpenReply&& from) noexcept
      : OpenReply(nullptr, std::move(from)) {}
  inline OpenReply& operator=(const OpenReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpenReply& operator=(OpenReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OpenReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const OpenReply* internal_default_instance() {
    return reinterpret_cast<const OpenReply*>(
        &_OpenReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(OpenReply& a, OpenReply& b) { a.Swap(&b); }
  inline void Swap(OpenReply* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpenReply* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OpenReply* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<OpenReply>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const OpenReply& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const OpenReply& from) { OpenReply::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(OpenReply* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "remote.OpenReply"; }

 protected:
  explicit OpenReply(::google::protobuf::Arena* arena);
  OpenReply(::google::protobuf::Arena* arena, const OpenReply& from);
  OpenReply(::google::protobuf::Arena* arena, OpenReply&& from) noexcept
      : OpenReply(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kErrorFieldNumber = 2,
  };
  // string error = 2;
  void clear_error() ;
  const std::string& error() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_error(Arg_&& arg, Args_... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* value);

  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(
      const std::string& value);
  std::string* _internal_mutable_error();

  public:
  // @@protoc_insertion_point(class_scope:remote.OpenReply)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      30, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr error_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_leveldbr_2eproto;
};
// -------------------------------------------------------------------

class LookupRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:remote.LookupRequest) */ {
 public:
  inline LookupRequest() : LookupRequest(nullptr) {}
  ~LookupRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LookupRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline LookupRequest(const LookupRequest& from) : LookupRequest(nullptr, from) {}
  inline LookupRequest(LookupRequest&& from) noexcept
      : LookupRequest(nullptr, std::move(from)) {}
  inline LookupRequest& operator=(const LookupRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LookupRequest& operator=(LookupRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LookupRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LookupRequest* internal_default_instance() {
    return reinterpret_cast<const LookupRequest*>(
        &_LookupRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(LookupRequest& a, LookupRequest& b) { a.Swap(&b); }
  inline void Swap(LookupRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LookupRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LookupRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<LookupRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LookupRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const LookupRequest& from) { LookupRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(LookupRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "remote.LookupRequest"; }

 protected:
  explicit LookupRequest(::google::protobuf::Arena* arena);
  LookupRequest(::google::protobuf::Arena* arena, const LookupRequest& from);
  LookupRequest(::google::protobuf::Arena* arena, LookupRequest&& from) noexcept
      : LookupRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLowerFieldNumber = 1,
    kUpperFieldNumber = 2,
    kSnapshotFieldNumber = 3,
  };
  // bytes lower = 1;
  void clear_lower() ;
  const std::string& lower() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_lower(Arg_&& arg, Args_... args);
  std::string* mutable_lower();
  PROTOBUF_NODISCARD std::string* release_lower();
  void set_allocated_lower(std::string* value);

  private:
  const std::string& _internal_lower() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_lower(
      const std::string& value);
  std::string* _internal_mutable_lower();

  public:
  // bytes upper = 2;
  void clear_upper() ;
  const std::string& upper() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_upper(Arg_&& arg, Args_... args);
  std::string* mutable_upper();
  PROTOBUF_NODISCARD std::string* release_upper();
  void set_allocated_upper(std::string* value);

  private:
  const std::string& _internal_upper() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_upper(
      const std::string& value);
  std::string* _internal_mutable_upper();

  public:
  // uint64 snapshot = 3;
  void clear_snapshot() ;
  ::uint64_t snapshot() const;
  void set_snapshot(::uint64_t value);

  private:
  ::uint64_t _internal_snapshot() const;
  void _internal_set_snapshot(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:remote.LookupRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr lower_;
    ::google::protobuf::internal::ArenaStringPtr upper_;
    ::uint64_t snapshot_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_leveldbr_2eproto;
};
// -------------------------------------------------------------------

class LookupReply final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:remote.LookupReply) */ {
 public:
  inline LookupReply() : LookupReply(nullptr) {}
  ~LookupReply() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LookupReply(
      ::google::protobuf::internal::ConstantInitialized);

  inline LookupReply(const LookupReply& from) : LookupReply(nullptr, from) {}
  inline LookupReply(LookupReply&& from) noexcept
      : LookupReply(nullptr, std::move(from)) {}
  inline LookupReply& operator=(const LookupReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline LookupReply& operator=(LookupReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LookupReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const LookupReply* internal_default_instance() {
    return reinterpret_cast<const LookupReply*>(
        &_LookupReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(LookupReply& a, LookupReply& b) { a.Swap(&b); }
  inline void Swap(LookupReply* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LookupReply* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LookupReply* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<LookupReply>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LookupReply& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const LookupReply& from) { LookupReply::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(LookupReply* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "remote.LookupReply"; }

 protected:
  explicit LookupReply(::google::protobuf::Arena* arena);
  LookupReply(::google::protobuf::Arena* arena, const LookupReply& from);
  LookupReply(::google::protobuf::Arena* arena, LookupReply&& from) noexcept
      : LookupReply(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kErrorFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // string error = 2;
  void clear_error() ;
  const std::string& error() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_error(Arg_&& arg, Args_... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* value);

  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(
      const std::string& value);
  std::string* _internal_mutable_error();

  public:
  // uint64 id = 1;
  void clear_id() ;
  ::uint64_t id() const;
  void set_id(::uint64_t value);

  private:
  ::uint64_t _internal_id() const;
  void _internal_set_id(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:remote.LookupReply)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      32, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr error_;
    ::uint64_t id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_leveldbr_2eproto;
};
// -------------------------------------------------------------------

class LookupNextRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:remote.LookupNextRequest) */ {
 public:
  inline LookupNextRequest() : LookupNextRequest(nullptr) {}
  ~LookupNextRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LookupNextRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline LookupNextRequest(const LookupNextRequest& from) : LookupNextRequest(nullptr, from) {}
  inline LookupNextRequest(LookupNextRequest&& from) noexcept
      : LookupNextRequest(nullptr, std::move(from)) {}
  inline LookupNextRequest& operator=(const LookupNextRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LookupNextRequest& operator=(LookupNextRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LookupNextRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LookupNextRequest* internal_default_instance() {
    return reinterpret_cast<const LookupNextRequest*>(
        &_LookupNextRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(LookupNextRequest& a, LookupNextRequest& b) { a.Swap(&b); }
  inline void Swap(LookupNextRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LookupNextRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LookupNextRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<LookupNextRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LookupNextRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const LookupNextRequest& from) { LookupNextRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(LookupNextRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "remote.LookupNextRequest"; }

 protected:
  explicit LookupNextRequest(::google::protobuf::Arena* arena);
  LookupNextRequest(::google::protobuf::Arena* arena, const LookupNextRequest& from);
  LookupNextRequest(::google::protobuf::Arena* arena, LookupNextRequest&& from) noexcept
      : LookupNextRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
  };
  // uint64 id = 1;
  void clear_id() ;
  ::uint64_t id() const;
  void set_id(::uint64_t value);

  private:
  ::uint64_t _internal_id() const;
  void _internal_set_id(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:remote.LookupNextRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::uint64_t id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_leveldbr_2eproto;
};
// -------------------------------------------------------------------

class KeyValue final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:remote.KeyValue) */ {
 public:
  inline KeyValue() : KeyValue(nullptr) {}
  ~KeyValue() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR KeyValue(
      ::google::protobuf::internal::ConstantInitialized);

  inline KeyValue(const KeyValue& from) : KeyValue(nullptr, from) {}
  inline KeyValue(KeyValue&& from) noexcept
      : KeyValue(nullptr, std::move(from)) {}
  inline KeyValue& operator=(const KeyValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeyValue& operator=(KeyValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KeyValue& default_instance() {
    return *internal_default_instance();
  }
  static inline const KeyValue* internal_default_instance() {
    return reinterpret_cast<const KeyValue*>(
        &_KeyValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(KeyValue& a, KeyValue& b) { a.Swap(&b); }
  inline void Swap(KeyValue* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeyValue* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KeyValue* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<KeyValue>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const KeyValue& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const KeyValue& from) { KeyValue::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(KeyValue* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "remote.KeyValue"; }

 protected:
  explicit KeyValue(::google::protobuf::Arena* arena);
  KeyValue(::google::protobuf::Arena* arena, const KeyValue& from);
  KeyValue(::google::protobuf::Arena* arena, KeyValue&& from) noexcept
      : KeyValue(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // bytes key = 1;
  void clear_key() ;
  const std::string& key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* value);

  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(
      const std::string& value);
  std::string* _internal_mutable_key();

  public:
  // bytes value = 2;
  void clear_value() ;
  const std::string& value() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_value(Arg_&& arg, Args_... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);

  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(
      const std::string& value);
  std::string* _internal_mutable_value();

  public:
  // @@protoc_insertion_point(class_scope:remote.KeyValue)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr key_;
    ::google::protobuf::internal::ArenaStringPtr value_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_leveldbr_2eproto;
};
// -------------------------------------------------------------------

class GetRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:remote.GetRequest) */ {
 public:
  inline GetRequest() : GetRequest(nullptr) {}
  ~GetRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetRequest(const GetRequest& from) : GetRequest(nullptr, from) {}
  inline GetRequest(GetRequest&& from) noexcept
      : GetRequest(nullptr, std::move(from)) {}
  inline GetRequest& operator=(const GetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRequest& operator=(GetRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRequest* internal_default_instance() {
    return reinterpret_cast<const GetRequest*>(
        &_GetRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(GetRequest& a, GetRequest& b) { a.Swap(&b); }
  inline void Swap(GetRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<GetRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetRequest& from) { GetRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "remote.GetRequest"; }

 protected:
  explicit GetRequest(::google::protobuf::Arena* arena);
  GetRequest(::google::protobuf::Arena* arena, const GetRequest& from);
  GetRequest(::google::protobuf::Arena* arena, GetRequest&& from) noexcept
      : GetRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kKeyFieldNumber = 1,
    kSnapshotFieldNumber = 2,
  };
  // bytes key = 1;
  void clear_key() ;
  const std::string& key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* value);

  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(
      const std::string& value);
  std::string* _internal_mutable_key();

  public:
  // uint64 snapshot = 2;
  void clear_snapshot() ;
  ::uint64_t snapshot() const;
  void set_snapshot(::uint64_t value);

  private:
  ::uint64_t _internal_snapshot() const;
  void _internal_set_snapshot(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:remote.GetRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr key_;
    ::uint64_t snapshot_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_leveldbr_2eproto;
};
// -------------------------------------------------------------------

class GetReply final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:remote.GetReply) */ {
 public:
  inline GetReply() : GetReply(nullptr) {}
  ~GetReply() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetReply(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetReply(const GetReply& from) : GetReply(nullptr, from) {}
  inline GetReply(GetReply&& from) noexcept
      : GetReply(nullptr, std::move(from)) {}
  inline GetReply& operator=(const GetReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetReply& operator=(GetReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetReply* internal_default_instance() {
    return reinterpret_cast<const GetReply*>(
        &_GetReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(GetReply& a, GetReply& b) { a.Swap(&b); }
  inline void Swap(GetReply* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetReply* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetReply* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<GetReply>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetReply& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetReply& from) { GetReply::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetReply* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "remote.GetReply"; }

 protected:
  explicit GetReply(::google::protobuf::Arena* arena);
  GetReply(::google::protobuf::Arena* arena, const GetReply& from);
  GetReply(::google::protobuf::Arena* arena, GetReply&& from) noexcept
      : GetReply(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kValueFieldNumber = 1,
    kErrorFieldNumber = 2,
  };
  // bytes value = 1;
  void clear_value() ;
  const std::string& value() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_value(Arg_&& arg, Args_... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);

  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(
      const std::string& value);
  std::string* _internal_mutable_value();

  public:
  // string error = 2;
  void clear_error() ;
  const std::string& error() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_error(Arg_&& arg, Args_... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* value);

  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(
      const std::string& value);
  std::string* _internal_mutable_error();

  public:
  // @@protoc_insertion_point(class_scope:remote.GetReply)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      29, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr value_;
    ::google::protobuf::internal::ArenaStringPtr error_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_leveldbr_2eproto;
};
// -------------------------------------------------------------------

class CloseRequest final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:remote.CloseRequest) */ {
 public:
  inline CloseRequest() : CloseRequest(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CloseRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline CloseRequest(const CloseRequest& from) : CloseRequest(nullptr, from) {}
  inline CloseRequest(CloseRequest&& from) noexcept
      : CloseRequest(nullptr, std::move(from)) {}
  inline CloseRequest& operator=(const CloseRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CloseRequest& operator=(CloseRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CloseRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CloseRequest* internal_default_instance() {
    return reinterpret_cast<const CloseRequest*>(
        &_CloseRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(CloseRequest& a, CloseRequest& b) { a.Swap(&b); }
  inline void Swap(CloseRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CloseRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CloseRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<CloseRequest>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CloseRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CloseRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "remote.CloseRequest"; }

 protected:
  explicit CloseRequest(::google::protobuf::Arena* arena);
  CloseRequest(::google::protobuf::Arena* arena, const CloseRequest& from);
  CloseRequest(::google::protobuf::Arena* arena, CloseRequest&& from) noexcept
      : CloseRequest(arena) {
    *this = ::std::move(from);
  }

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:remote.CloseRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_leveldbr_2eproto;
};
// -------------------------------------------------------------------

class CloseReply final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:remote.CloseReply) */ {
 public:
  inline CloseReply() : CloseReply(nullptr) {}
  ~CloseReply() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CloseReply(
      ::google::protobuf::internal::ConstantInitialized);

  inline CloseReply(const CloseReply& from) : CloseReply(nullptr, from) {}
  inline CloseReply(CloseReply&& from) noexcept
      : CloseReply(nullptr, std::move(from)) {}
  inline CloseReply& operator=(const CloseReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline CloseReply& operator=(CloseReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CloseReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const CloseReply* internal_default_instance() {
    return reinterpret_cast<const CloseReply*>(
        &_CloseReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(CloseReply& a, CloseReply& b) { a.Swap(&b); }
  inline void Swap(CloseReply* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CloseReply* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CloseReply* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<CloseReply>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CloseReply& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CloseReply& from) { CloseReply::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CloseReply* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "remote.CloseReply"; }

 protected:
  explicit CloseReply(::google::protobuf::Arena* arena);
  CloseReply(::google::protobuf::Arena* arena, const CloseReply& from);
  CloseReply(::google::protobuf::Arena* arena, CloseReply&& from) noexcept
      : CloseReply(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kErrorFieldNumber = 1,
  };
  // string error = 1;
  void clear_error() ;
  const std::string& error() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_error(Arg_&& arg, Args_... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* value);

  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(
      const std::string& value);
  std::string* _internal_mutable_error();

  public:
  // @@protoc_insertion_point(class_scope:remote.CloseReply)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      31, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr error_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_leveldbr_2eproto;
};
// -------------------------------------------------------------------

class WriteRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:remote.WriteRequest) */ {
 public:
  inline WriteRequest() : WriteRequest(nullptr) {}
  ~WriteRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR WriteRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline WriteRequest(const WriteRequest& from) : WriteRequest(nullptr, from) {}
  inline WriteRequest(WriteRequest&& from) noexcept
      : WriteRequest(nullptr, std::move(from)) {}
  inline WriteRequest& operator=(const WriteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline WriteRequest& operator=(WriteRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WriteRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const WriteRequest* internal_default_instance() {
    return reinterpret_cast<const WriteRequest*>(
        &_WriteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(WriteRequest& a, WriteRequest& b) { a.Swap(&b); }
  inline void Swap(WriteRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WriteRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WriteRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<WriteRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const WriteRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const WriteRequest& from) { WriteRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(WriteRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "remote.WriteRequest"; }

 protected:
  explicit WriteRequest(::google::protobuf::Arena* arena);
  WriteRequest(::google::protobuf::Arena* arena, const WriteRequest& from);
  WriteRequest(::google::protobuf::Arena* arena, WriteRequest&& from) noexcept
      : WriteRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEntriesFieldNumber = 1,
  };
  // repeated .remote.KeyValue entries = 1;
  int entries_size() const;
  private:
  int _internal_entries_size() const;

  public:
  void clear_entries() ;
  ::remote::KeyValue* mutable_entries(int index);
  ::google::protobuf::RepeatedPtrField<::remote::KeyValue>* mutable_entries();

  private:
  const ::google::protobuf::RepeatedPtrField<::remote::KeyValue>& _internal_entries() const;
  ::google::protobuf::RepeatedPtrField<::remote::KeyValue>* _internal_mutable_entries();
  public:
  const ::remote::KeyValue& entries(int index) const;
  ::remote::KeyValue* add_entries();
  const ::google::protobuf::RepeatedPtrField<::remote::KeyValue>& entries() const;
  // @@protoc_insertion_point(class_scope:remote.WriteRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::remote::KeyValue > entries_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_leveldbr_2eproto;
};
// -------------------------------------------------------------------

class LookupNextReply final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:remote.LookupNextReply) */ {
 public:
  inline LookupNextReply() : LookupNextReply(nullptr) {}
  ~LookupNextReply() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LookupNextReply(
      ::google::protobuf::internal::ConstantInitialized);

  inline LookupNextReply(const LookupNextReply& from) : LookupNextReply(nullptr, from) {}
  inline LookupNextReply(LookupNextReply&& from) noexcept
      : LookupNextReply(nullptr, std::move(from)) {}
  inline LookupNextReply& operator=(const LookupNextReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline LookupNextReply& operator=(LookupNextReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LookupNextReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const LookupNextReply* internal_default_instance() {
    return reinterpret_cast<const LookupNextReply*>(
        &_LookupNextReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 18;
  friend void swap(LookupNextReply& a, LookupNextReply& b) { a.Swap(&b); }
  inline void Swap(LookupNextReply* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LookupNextReply* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LookupNextReply* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<LookupNextReply>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LookupNextReply& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const LookupNextReply& from) { LookupNextReply::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(LookupNextReply* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "remote.LookupNextReply"; }

 protected:
  explicit LookupNextReply(::google::protobuf::Arena* arena);
  LookupNextReply(::google::protobuf::Arena* arena, const LookupNextReply& from);
  LookupNextReply(::google::protobuf::Arena* arena, LookupNextReply&& from) noexcept
      : LookupNextReply(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEntriesFieldNumber = 1,
    kErrorFieldNumber = 2,
  };
  // repeated .remote.KeyValue entries = 1;
  int entries_size() const;
  private:
  int _internal_entries_size() const;

  public:
  void clear_entries() ;
  ::remote::KeyValue* mutable_entries(int index);
  ::google::protobuf::RepeatedPtrField<::remote::KeyValue>* mutable_entries();

  private:
  const ::google::protobuf::RepeatedPtrField<::remote::KeyValue>& _internal_entries() const;
  ::google::protobuf::RepeatedPtrField<::remote::KeyValue>* _internal_mutable_entries();
  public:
  const ::remote::KeyValue& entries(int index) const;
  ::remote::KeyValue* add_entries();
  const ::google::protobuf::RepeatedPtrField<::remote::KeyValue>& entries() const;
  // string error = 2;
  void clear_error() ;
  const std::string& error() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_error(Arg_&& arg, Args_... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* value);

  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(
      const std::string& value);
  std::string* _internal_mutable_error();

  public:
  // @@protoc_insertion_point(class_scope:remote.LookupNextReply)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      36, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::remote::KeyValue > entries_;
    ::google::protobuf::internal::ArenaStringPtr error_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_leveldbr_2eproto;
};
// -------------------------------------------------------------------

class OutMessage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:remote.OutMessage) */ {
 public:
  inline OutMessage() : OutMessage(nullptr) {}
  ~OutMessage() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR OutMessage(
      ::google::protobuf::internal::ConstantInitialized);

  inline OutMessage(const OutMessage& from) : OutMessage(nullptr, from) {}
  inline OutMessage(OutMessage&& from) noexcept
      : OutMessage(nullptr, std::move(from)) {}
  inline OutMessage& operator=(const OutMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline OutMessage& operator=(OutMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OutMessage& default_instance() {
    return *internal_default_instance();
  }
  enum ReplyCase {
    kOpen = 1,
    kClose = 3,
    kGet = 4,
    kPut = 5,
    kWrite = 6,
    kLookup = 7,
    kNext = 8,
    kSnapshot = 9,
    REPLY_NOT_SET = 0,
  };
  static inline const OutMessage* internal_default_instance() {
    return reinterpret_cast<const OutMessage*>(
        &_OutMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(OutMessage& a, OutMessage& b) { a.Swap(&b); }
  inline void Swap(OutMessage* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OutMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OutMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<OutMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const OutMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const OutMessage& from) { OutMessage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(OutMessage* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "remote.OutMessage"; }

 protected:
  explicit OutMessage(::google::protobuf::Arena* arena);
  OutMessage(::google::protobuf::Arena* arena, const OutMessage& from);
  OutMessage(::google::protobuf::Arena* arena, OutMessage&& from) noexcept
      : OutMessage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOpenFieldNumber = 1,
    kCloseFieldNumber = 3,
    kGetFieldNumber = 4,
    kPutFieldNumber = 5,
    kWriteFieldNumber = 6,
    kLookupFieldNumber = 7,
    kNextFieldNumber = 8,
    kSnapshotFieldNumber = 9,
  };
  // .remote.OpenReply open = 1;
  bool has_open() const;
  private:
  bool _internal_has_open() const;

  public:
  void clear_open() ;
  const ::remote::OpenReply& open() const;
  PROTOBUF_NODISCARD ::remote::OpenReply* release_open();
  ::remote::OpenReply* mutable_open();
  void set_allocated_open(::remote::OpenReply* value);
  void unsafe_arena_set_allocated_open(::remote::OpenReply* value);
  ::remote::OpenReply* unsafe_arena_release_open();

  private:
  const ::remote::OpenReply& _internal_open() const;
  ::remote::OpenReply* _internal_mutable_open();

  public:
  // .remote.CloseReply close = 3;
  bool has_close() const;
  private:
  bool _internal_has_close() const;

  public:
  void clear_close() ;
  const ::remote::CloseReply& close() const;
  PROTOBUF_NODISCARD ::remote::CloseReply* release_close();
  ::remote::CloseReply* mutable_close();
  void set_allocated_close(::remote::CloseReply* value);
  void unsafe_arena_set_allocated_close(::remote::CloseReply* value);
  ::remote::CloseReply* unsafe_arena_release_close();

  private:
  const ::remote::CloseReply& _internal_close() const;
  ::remote::CloseReply* _internal_mutable_close();

  public:
  // .remote.GetReply get = 4;
  bool has_get() const;
  private:
  bool _internal_has_get() const;

  public:
  void clear_get() ;
  const ::remote::GetReply& get() const;
  PROTOBUF_NODISCARD ::remote::GetReply* release_get();
  ::remote::GetReply* mutable_get();
  void set_allocated_get(::remote::GetReply* value);
  void unsafe_arena_set_allocated_get(::remote::GetReply* value);
  ::remote::GetReply* unsafe_arena_release_get();

  private:
  const ::remote::GetReply& _internal_get() const;
  ::remote::GetReply* _internal_mutable_get();

  public:
  // .remote.PutReply put = 5;
  bool has_put() const;
  private:
  bool _internal_has_put() const;

  public:
  void clear_put() ;
  const ::remote::PutReply& put() const;
  PROTOBUF_NODISCARD ::remote::PutReply* release_put();
  ::remote::PutReply* mutable_put();
  void set_allocated_put(::remote::PutReply* value);
  void unsafe_arena_set_allocated_put(::remote::PutReply* value);
  ::remote::PutReply* unsafe_arena_release_put();

  private:
  const ::remote::PutReply& _internal_put() const;
  ::remote::PutReply* _internal_mutable_put();

  public:
  // .remote.WriteReply write = 6;
  bool has_write() const;
  private:
  bool _internal_has_write() const;

  public:
  void clear_write() ;
  const ::remote::WriteReply& write() const;
  PROTOBUF_NODISCARD ::remote::WriteReply* release_write();
  ::remote::WriteReply* mutable_write();
  void set_allocated_write(::remote::WriteReply* value);
  void unsafe_arena_set_allocated_write(::remote::WriteReply* value);
  ::remote::WriteReply* unsafe_arena_release_write();

  private:
  const ::remote::WriteReply& _internal_write() const;
  ::remote::WriteReply* _internal_mutable_write();

  public:
  // .remote.LookupReply lookup = 7;
  bool has_lookup() const;
  private:
  bool _internal_has_lookup() const;

  public:
  void clear_lookup() ;
  const ::remote::LookupReply& lookup() const;
  PROTOBUF_NODISCARD ::remote::LookupReply* release_lookup();
  ::remote::LookupReply* mutable_lookup();
  void set_allocated_lookup(::remote::LookupReply* value);
  void unsafe_arena_set_allocated_lookup(::remote::LookupReply* value);
  ::remote::LookupReply* unsafe_arena_release_lookup();

  private:
  const ::remote::LookupReply& _internal_lookup() const;
  ::remote::LookupReply* _internal_mutable_lookup();

  public:
  // .remote.LookupNextReply next = 8;
  bool has_next() const;
  private:
  bool _internal_has_next() const;

  public:
  void clear_next() ;
  const ::remote::LookupNextReply& next() const;
  PROTOBUF_NODISCARD ::remote::LookupNextReply* release_next();
  ::remote::LookupNextReply* mutable_next();
  void set_allocated_next(::remote::LookupNextReply* value);
  void unsafe_arena_set_allocated_next(::remote::LookupNextReply* value);
  ::remote::LookupNextReply* unsafe_arena_release_next();

  private:
  const ::remote::LookupNextReply& _internal_next() const;
  ::remote::LookupNextReply* _internal_mutable_next();

  public:
  // .remote.SnapshotReply snapshot = 9;
  bool has_snapshot() const;
  private:
  bool _internal_has_snapshot() const;

  public:
  void clear_snapshot() ;
  const ::remote::SnapshotReply& snapshot() const;
  PROTOBUF_NODISCARD ::remote::SnapshotReply* release_snapshot();
  ::remote::SnapshotReply* mutable_snapshot();
  void set_allocated_snapshot(::remote::SnapshotReply* value);
  void unsafe_arena_set_allocated_snapshot(::remote::SnapshotReply* value);
  ::remote::SnapshotReply* unsafe_arena_release_snapshot();

  private:
  const ::remote::SnapshotReply& _internal_snapshot() const;
  ::remote::SnapshotReply* _internal_mutable_snapshot();

  public:
  void clear_reply();
  ReplyCase reply_case() const;
  // @@protoc_insertion_point(class_scope:remote.OutMessage)
 private:
  class _Internal;
  void set_has_open();
  void set_has_close();
  void set_has_get();
  void set_has_put();
  void set_has_write();
  void set_has_lookup();
  void set_has_next();
  void set_has_snapshot();
  inline bool has_reply() const;
  inline void clear_has_reply();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 8, 8,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    union ReplyUnion {
      constexpr ReplyUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::remote::OpenReply* open_;
      ::remote::CloseReply* close_;
      ::remote::GetReply* get_;
      ::remote::PutReply* put_;
      ::remote::WriteReply* write_;
      ::remote::LookupReply* lookup_;
      ::remote::LookupNextReply* next_;
      ::remote::SnapshotReply* snapshot_;
    } reply_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_leveldbr_2eproto;
};
// -------------------------------------------------------------------

class InMessage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:remote.InMessage) */ {
 public:
  inline InMessage() : InMessage(nullptr) {}
  ~InMessage() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR InMessage(
      ::google::protobuf::internal::ConstantInitialized);

  inline InMessage(const InMessage& from) : InMessage(nullptr, from) {}
  inline InMessage(InMessage&& from) noexcept
      : InMessage(nullptr, std::move(from)) {}
  inline InMessage& operator=(const InMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline InMessage& operator=(InMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InMessage& default_instance() {
    return *internal_default_instance();
  }
  enum RequestCase {
    kOpen = 1,
    kClose = 3,
    kGet = 4,
    kPut = 5,
    kWrite = 6,
    kLookup = 7,
    kNext = 8,
    kSnapshot = 9,
    REQUEST_NOT_SET = 0,
  };
  static inline const InMessage* internal_default_instance() {
    return reinterpret_cast<const InMessage*>(
        &_InMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(InMessage& a, InMessage& b) { a.Swap(&b); }
  inline void Swap(InMessage* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<InMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const InMessage& from) { InMessage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(InMessage* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "remote.InMessage"; }

 protected:
  explicit InMessage(::google::protobuf::Arena* arena);
  InMessage(::google::protobuf::Arena* arena, const InMessage& from);
  InMessage(::google::protobuf::Arena* arena, InMessage&& from) noexcept
      : InMessage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOpenFieldNumber = 1,
    kCloseFieldNumber = 3,
    kGetFieldNumber = 4,
    kPutFieldNumber = 5,
    kWriteFieldNumber = 6,
    kLookupFieldNumber = 7,
    kNextFieldNumber = 8,
    kSnapshotFieldNumber = 9,
  };
  // .remote.OpenRequest open = 1;
  bool has_open() const;
  private:
  bool _internal_has_open() const;

  public:
  void clear_open() ;
  const ::remote::OpenRequest& open() const;
  PROTOBUF_NODISCARD ::remote::OpenRequest* release_open();
  ::remote::OpenRequest* mutable_open();
  void set_allocated_open(::remote::OpenRequest* value);
  void unsafe_arena_set_allocated_open(::remote::OpenRequest* value);
  ::remote::OpenRequest* unsafe_arena_release_open();

  private:
  const ::remote::OpenRequest& _internal_open() const;
  ::remote::OpenRequest* _internal_mutable_open();

  public:
  // .remote.CloseRequest close = 3;
  bool has_close() const;
  private:
  bool _internal_has_close() const;

  public:
  void clear_close() ;
  const ::remote::CloseRequest& close() const;
  PROTOBUF_NODISCARD ::remote::CloseRequest* release_close();
  ::remote::CloseRequest* mutable_close();
  void set_allocated_close(::remote::CloseRequest* value);
  void unsafe_arena_set_allocated_close(::remote::CloseRequest* value);
  ::remote::CloseRequest* unsafe_arena_release_close();

  private:
  const ::remote::CloseRequest& _internal_close() const;
  ::remote::CloseRequest* _internal_mutable_close();

  public:
  // .remote.GetRequest get = 4;
  bool has_get() const;
  private:
  bool _internal_has_get() const;

  public:
  void clear_get() ;
  const ::remote::GetRequest& get() const;
  PROTOBUF_NODISCARD ::remote::GetRequest* release_get();
  ::remote::GetRequest* mutable_get();
  void set_allocated_get(::remote::GetRequest* value);
  void unsafe_arena_set_allocated_get(::remote::GetRequest* value);
  ::remote::GetRequest* unsafe_arena_release_get();

  private:
  const ::remote::GetRequest& _internal_get() const;
  ::remote::GetRequest* _internal_mutable_get();

  public:
  // .remote.PutRequest put = 5;
  bool has_put() const;
  private:
  bool _internal_has_put() const;

  public:
  void clear_put() ;
  const ::remote::PutRequest& put() const;
  PROTOBUF_NODISCARD ::remote::PutRequest* release_put();
  ::remote::PutRequest* mutable_put();
  void set_allocated_put(::remote::PutRequest* value);
  void unsafe_arena_set_allocated_put(::remote::PutRequest* value);
  ::remote::PutRequest* unsafe_arena_release_put();

  private:
  const ::remote::PutRequest& _internal_put() const;
  ::remote::PutRequest* _internal_mutable_put();

  public:
  // .remote.WriteRequest write = 6;
  bool has_write() const;
  private:
  bool _internal_has_write() const;

  public:
  void clear_write() ;
  const ::remote::WriteRequest& write() const;
  PROTOBUF_NODISCARD ::remote::WriteRequest* release_write();
  ::remote::WriteRequest* mutable_write();
  void set_allocated_write(::remote::WriteRequest* value);
  void unsafe_arena_set_allocated_write(::remote::WriteRequest* value);
  ::remote::WriteRequest* unsafe_arena_release_write();

  private:
  const ::remote::WriteRequest& _internal_write() const;
  ::remote::WriteRequest* _internal_mutable_write();

  public:
  // .remote.LookupRequest lookup = 7;
  bool has_lookup() const;
  private:
  bool _internal_has_lookup() const;

  public:
  void clear_lookup() ;
  const ::remote::LookupRequest& lookup() const;
  PROTOBUF_NODISCARD ::remote::LookupRequest* release_lookup();
  ::remote::LookupRequest* mutable_lookup();
  void set_allocated_lookup(::remote::LookupRequest* value);
  void unsafe_arena_set_allocated_lookup(::remote::LookupRequest* value);
  ::remote::LookupRequest* unsafe_arena_release_lookup();

  private:
  const ::remote::LookupRequest& _internal_lookup() const;
  ::remote::LookupRequest* _internal_mutable_lookup();

  public:
  // .remote.LookupNextRequest next = 8;
  bool has_next() const;
  private:
  bool _internal_has_next() const;

  public:
  void clear_next() ;
  const ::remote::LookupNextRequest& next() const;
  PROTOBUF_NODISCARD ::remote::LookupNextRequest* release_next();
  ::remote::LookupNextRequest* mutable_next();
  void set_allocated_next(::remote::LookupNextRequest* value);
  void unsafe_arena_set_allocated_next(::remote::LookupNextRequest* value);
  ::remote::LookupNextRequest* unsafe_arena_release_next();

  private:
  const ::remote::LookupNextRequest& _internal_next() const;
  ::remote::LookupNextRequest* _internal_mutable_next();

  public:
  // .remote.SnapshotRequest snapshot = 9;
  bool has_snapshot() const;
  private:
  bool _internal_has_snapshot() const;

  public:
  void clear_snapshot() ;
  const ::remote::SnapshotRequest& snapshot() const;
  PROTOBUF_NODISCARD ::remote::SnapshotRequest* release_snapshot();
  ::remote::SnapshotRequest* mutable_snapshot();
  void set_allocated_snapshot(::remote::SnapshotRequest* value);
  void unsafe_arena_set_allocated_snapshot(::remote::SnapshotRequest* value);
  ::remote::SnapshotRequest* unsafe_arena_release_snapshot();

  private:
  const ::remote::SnapshotRequest& _internal_snapshot() const;
  ::remote::SnapshotRequest* _internal_mutable_snapshot();

  public:
  void clear_request();
  RequestCase request_case() const;
  // @@protoc_insertion_point(class_scope:remote.InMessage)
 private:
  class _Internal;
  void set_has_open();
  void set_has_close();
  void set_has_get();
  void set_has_put();
  void set_has_write();
  void set_has_lookup();
  void set_has_next();
  void set_has_snapshot();
  inline bool has_request() const;
  inline void clear_has_request();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 8, 8,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    union RequestUnion {
      constexpr RequestUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::remote::OpenRequest* open_;
      ::remote::CloseRequest* close_;
      ::remote::GetRequest* get_;
      ::remote::PutRequest* put_;
      ::remote::WriteRequest* write_;
      ::remote::LookupRequest* lookup_;
      ::remote::LookupNextRequest* next_;
      ::remote::SnapshotRequest* snapshot_;
    } request_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_leveldbr_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// InMessage

// .remote.OpenRequest open = 1;
inline bool InMessage::has_open() const {
  return request_case() == kOpen;
}
inline bool InMessage::_internal_has_open() const {
  return request_case() == kOpen;
}
inline void InMessage::set_has_open() {
  _impl_._oneof_case_[0] = kOpen;
}
inline void InMessage::clear_open() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (request_case() == kOpen) {
    if (GetArena() == nullptr) {
      delete _impl_.request_.open_;
    }
    clear_has_request();
  }
}
inline ::remote::OpenRequest* InMessage::release_open() {
  // @@protoc_insertion_point(field_release:remote.InMessage.open)
  if (request_case() == kOpen) {
    clear_has_request();
    auto* temp = _impl_.request_.open_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_.open_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::remote::OpenRequest& InMessage::_internal_open() const {
  return request_case() == kOpen ? *_impl_.request_.open_ : reinterpret_cast<::remote::OpenRequest&>(::remote::_OpenRequest_default_instance_);
}
inline const ::remote::OpenRequest& InMessage::open() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:remote.InMessage.open)
  return _internal_open();
}
inline ::remote::OpenRequest* InMessage::unsafe_arena_release_open() {
  // @@protoc_insertion_point(field_unsafe_arena_release:remote.InMessage.open)
  if (request_case() == kOpen) {
    clear_has_request();
    auto* temp = _impl_.request_.open_;
    _impl_.request_.open_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InMessage::unsafe_arena_set_allocated_open(::remote::OpenRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request();
  if (value) {
    set_has_open();
    _impl_.request_.open_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:remote.InMessage.open)
}
inline ::remote::OpenRequest* InMessage::_internal_mutable_open() {
  if (request_case() != kOpen) {
    clear_request();
    set_has_open();
    _impl_.request_.open_ =
        ::google::protobuf::Message::DefaultConstruct<::remote::OpenRequest>(GetArena());
  }
  return _impl_.request_.open_;
}
inline ::remote::OpenRequest* InMessage::mutable_open() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::remote::OpenRequest* _msg = _internal_mutable_open();
  // @@protoc_insertion_point(field_mutable:remote.InMessage.open)
  return _msg;
}

// .remote.CloseRequest close = 3;
inline bool InMessage::has_close() const {
  return request_case() == kClose;
}
inline bool InMessage::_internal_has_close() const {
  return request_case() == kClose;
}
inline void InMessage::set_has_close() {
  _impl_._oneof_case_[0] = kClose;
}
inline void InMessage::clear_close() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (request_case() == kClose) {
    if (GetArena() == nullptr) {
      delete _impl_.request_.close_;
    }
    clear_has_request();
  }
}
inline ::remote::CloseRequest* InMessage::release_close() {
  // @@protoc_insertion_point(field_release:remote.InMessage.close)
  if (request_case() == kClose) {
    clear_has_request();
    auto* temp = _impl_.request_.close_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_.close_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::remote::CloseRequest& InMessage::_internal_close() const {
  return request_case() == kClose ? *_impl_.request_.close_ : reinterpret_cast<::remote::CloseRequest&>(::remote::_CloseRequest_default_instance_);
}
inline const ::remote::CloseRequest& InMessage::close() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:remote.InMessage.close)
  return _internal_close();
}
inline ::remote::CloseRequest* InMessage::unsafe_arena_release_close() {
  // @@protoc_insertion_point(field_unsafe_arena_release:remote.InMessage.close)
  if (request_case() == kClose) {
    clear_has_request();
    auto* temp = _impl_.request_.close_;
    _impl_.request_.close_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InMessage::unsafe_arena_set_allocated_close(::remote::CloseRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request();
  if (value) {
    set_has_close();
    _impl_.request_.close_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:remote.InMessage.close)
}
inline ::remote::CloseRequest* InMessage::_internal_mutable_close() {
  if (request_case() != kClose) {
    clear_request();
    set_has_close();
    _impl_.request_.close_ =
        ::google::protobuf::Message::DefaultConstruct<::remote::CloseRequest>(GetArena());
  }
  return _impl_.request_.close_;
}
inline ::remote::CloseRequest* InMessage::mutable_close() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::remote::CloseRequest* _msg = _internal_mutable_close();
  // @@protoc_insertion_point(field_mutable:remote.InMessage.close)
  return _msg;
}

// .remote.GetRequest get = 4;
inline bool InMessage::has_get() const {
  return request_case() == kGet;
}
inline bool InMessage::_internal_has_get() const {
  return request_case() == kGet;
}
inline void InMessage::set_has_get() {
  _impl_._oneof_case_[0] = kGet;
}
inline void InMessage::clear_get() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (request_case() == kGet) {
    if (GetArena() == nullptr) {
      delete _impl_.request_.get_;
    }
    clear_has_request();
  }
}
inline ::remote::GetRequest* InMessage::release_get() {
  // @@protoc_insertion_point(field_release:remote.InMessage.get)
  if (request_case() == kGet) {
    clear_has_request();
    auto* temp = _impl_.request_.get_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_.get_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::remote::GetRequest& InMessage::_internal_get() const {
  return request_case() == kGet ? *_impl_.request_.get_ : reinterpret_cast<::remote::GetRequest&>(::remote::_GetRequest_default_instance_);
}
inline const ::remote::GetRequest& InMessage::get() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:remote.InMessage.get)
  return _internal_get();
}
inline ::remote::GetRequest* InMessage::unsafe_arena_release_get() {
  // @@protoc_insertion_point(field_unsafe_arena_release:remote.InMessage.get)
  if (request_case() == kGet) {
    clear_has_request();
    auto* temp = _impl_.request_.get_;
    _impl_.request_.get_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InMessage::unsafe_arena_set_allocated_get(::remote::GetRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request();
  if (value) {
    set_has_get();
    _impl_.request_.get_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:remote.InMessage.get)
}
inline ::remote::GetRequest* InMessage::_internal_mutable_get() {
  if (request_case() != kGet) {
    clear_request();
    set_has_get();
    _impl_.request_.get_ =
        ::google::protobuf::Message::DefaultConstruct<::remote::GetRequest>(GetArena());
  }
  return _impl_.request_.get_;
}
inline ::remote::GetRequest* InMessage::mutable_get() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::remote::GetRequest* _msg = _internal_mutable_get();
  // @@protoc_insertion_point(field_mutable:remote.InMessage.get)
  return _msg;
}

// .remote.PutRequest put = 5;
inline bool InMessage::has_put() const {
  return request_case() == kPut;
}
inline bool InMessage::_internal_has_put() const {
  return request_case() == kPut;
}
inline void InMessage::set_has_put() {
  _impl_._oneof_case_[0] = kPut;
}
inline void InMessage::clear_put() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (request_case() == kPut) {
    if (GetArena() == nullptr) {
      delete _impl_.request_.put_;
    }
    clear_has_request();
  }
}
inline ::remote::PutRequest* InMessage::release_put() {
  // @@protoc_insertion_point(field_release:remote.InMessage.put)
  if (request_case() == kPut) {
    clear_has_request();
    auto* temp = _impl_.request_.put_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_.put_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::remote::PutRequest& InMessage::_internal_put() const {
  return request_case() == kPut ? *_impl_.request_.put_ : reinterpret_cast<::remote::PutRequest&>(::remote::_PutRequest_default_instance_);
}
inline const ::remote::PutRequest& InMessage::put() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:remote.InMessage.put)
  return _internal_put();
}
inline ::remote::PutRequest* InMessage::unsafe_arena_release_put() {
  // @@protoc_insertion_point(field_unsafe_arena_release:remote.InMessage.put)
  if (request_case() == kPut) {
    clear_has_request();
    auto* temp = _impl_.request_.put_;
    _impl_.request_.put_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InMessage::unsafe_arena_set_allocated_put(::remote::PutRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request();
  if (value) {
    set_has_put();
    _impl_.request_.put_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:remote.InMessage.put)
}
inline ::remote::PutRequest* InMessage::_internal_mutable_put() {
  if (request_case() != kPut) {
    clear_request();
    set_has_put();
    _impl_.request_.put_ =
        ::google::protobuf::Message::DefaultConstruct<::remote::PutRequest>(GetArena());
  }
  return _impl_.request_.put_;
}
inline ::remote::PutRequest* InMessage::mutable_put() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::remote::PutRequest* _msg = _internal_mutable_put();
  // @@protoc_insertion_point(field_mutable:remote.InMessage.put)
  return _msg;
}

// .remote.WriteRequest write = 6;
inline bool InMessage::has_write() const {
  return request_case() == kWrite;
}
inline bool InMessage::_internal_has_write() const {
  return request_case() == kWrite;
}
inline void InMessage::set_has_write() {
  _impl_._oneof_case_[0] = kWrite;
}
inline void InMessage::clear_write() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (request_case() == kWrite) {
    if (GetArena() == nullptr) {
      delete _impl_.request_.write_;
    }
    clear_has_request();
  }
}
inline ::remote::WriteRequest* InMessage::release_write() {
  // @@protoc_insertion_point(field_release:remote.InMessage.write)
  if (request_case() == kWrite) {
    clear_has_request();
    auto* temp = _impl_.request_.write_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_.write_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::remote::WriteRequest& InMessage::_internal_write() const {
  return request_case() == kWrite ? *_impl_.request_.write_ : reinterpret_cast<::remote::WriteRequest&>(::remote::_WriteRequest_default_instance_);
}
inline const ::remote::WriteRequest& InMessage::write() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:remote.InMessage.write)
  return _internal_write();
}
inline ::remote::WriteRequest* InMessage::unsafe_arena_release_write() {
  // @@protoc_insertion_point(field_unsafe_arena_release:remote.InMessage.write)
  if (request_case() == kWrite) {
    clear_has_request();
    auto* temp = _impl_.request_.write_;
    _impl_.request_.write_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InMessage::unsafe_arena_set_allocated_write(::remote::WriteRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request();
  if (value) {
    set_has_write();
    _impl_.request_.write_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:remote.InMessage.write)
}
inline ::remote::WriteRequest* InMessage::_internal_mutable_write() {
  if (request_case() != kWrite) {
    clear_request();
    set_has_write();
    _impl_.request_.write_ =
        ::google::protobuf::Message::DefaultConstruct<::remote::WriteRequest>(GetArena());
  }
  return _impl_.request_.write_;
}
inline ::remote::WriteRequest* InMessage::mutable_write() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::remote::WriteRequest* _msg = _internal_mutable_write();
  // @@protoc_insertion_point(field_mutable:remote.InMessage.write)
  return _msg;
}

// .remote.LookupRequest lookup = 7;
inline bool InMessage::has_lookup() const {
  return request_case() == kLookup;
}
inline bool InMessage::_internal_has_lookup() const {
  return request_case() == kLookup;
}
inline void InMessage::set_has_lookup() {
  _impl_._oneof_case_[0] = kLookup;
}
inline void InMessage::clear_lookup() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (request_case() == kLookup) {
    if (GetArena() == nullptr) {
      delete _impl_.request_.lookup_;
    }
    clear_has_request();
  }
}
inline ::remote::LookupRequest* InMessage::release_lookup() {
  // @@protoc_insertion_point(field_release:remote.InMessage.lookup)
  if (request_case() == kLookup) {
    clear_has_request();
    auto* temp = _impl_.request_.lookup_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_.lookup_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::remote::LookupRequest& InMessage::_internal_lookup() const {
  return request_case() == kLookup ? *_impl_.request_.lookup_ : reinterpret_cast<::remote::LookupRequest&>(::remote::_LookupRequest_default_instance_);
}
inline const ::remote::LookupRequest& InMessage::lookup() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:remote.InMessage.lookup)
  return _internal_lookup();
}
inline ::remote::LookupRequest* InMessage::unsafe_arena_release_lookup() {
  // @@protoc_insertion_point(field_unsafe_arena_release:remote.InMessage.lookup)
  if (request_case() == kLookup) {
    clear_has_request();
    auto* temp = _impl_.request_.lookup_;
    _impl_.request_.lookup_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InMessage::unsafe_arena_set_allocated_lookup(::remote::LookupRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request();
  if (value) {
    set_has_lookup();
    _impl_.request_.lookup_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:remote.InMessage.lookup)
}
inline ::remote::LookupRequest* InMessage::_internal_mutable_lookup() {
  if (request_case() != kLookup) {
    clear_request();
    set_has_lookup();
    _impl_.request_.lookup_ =
        ::google::protobuf::Message::DefaultConstruct<::remote::LookupRequest>(GetArena());
  }
  return _impl_.request_.lookup_;
}
inline ::remote::LookupRequest* InMessage::mutable_lookup() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::remote::LookupRequest* _msg = _internal_mutable_lookup();
  // @@protoc_insertion_point(field_mutable:remote.InMessage.lookup)
  return _msg;
}

// .remote.LookupNextRequest next = 8;
inline bool InMessage::has_next() const {
  return request_case() == kNext;
}
inline bool InMessage::_internal_has_next() const {
  return request_case() == kNext;
}
inline void InMessage::set_has_next() {
  _impl_._oneof_case_[0] = kNext;
}
inline void InMessage::clear_next() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (request_case() == kNext) {
    if (GetArena() == nullptr) {
      delete _impl_.request_.next_;
    }
    clear_has_request();
  }
}
inline ::remote::LookupNextRequest* InMessage::release_next() {
  // @@protoc_insertion_point(field_release:remote.InMessage.next)
  if (request_case() == kNext) {
    clear_has_request();
    auto* temp = _impl_.request_.next_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_.next_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::remote::LookupNextRequest& InMessage::_internal_next() const {
  return request_case() == kNext ? *_impl_.request_.next_ : reinterpret_cast<::remote::LookupNextRequest&>(::remote::_LookupNextRequest_default_instance_);
}
inline const ::remote::LookupNextRequest& InMessage::next() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:remote.InMessage.next)
  return _internal_next();
}
inline ::remote::LookupNextRequest* InMessage::unsafe_arena_release_next() {
  // @@protoc_insertion_point(field_unsafe_arena_release:remote.InMessage.next)
  if (request_case() == kNext) {
    clear_has_request();
    auto* temp = _impl_.request_.next_;
    _impl_.request_.next_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InMessage::unsafe_arena_set_allocated_next(::remote::LookupNextRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request();
  if (value) {
    set_has_next();
    _impl_.request_.next_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:remote.InMessage.next)
}
inline ::remote::LookupNextRequest* InMessage::_internal_mutable_next() {
  if (request_case() != kNext) {
    clear_request();
    set_has_next();
    _impl_.request_.next_ =
        ::google::protobuf::Message::DefaultConstruct<::remote::LookupNextRequest>(GetArena());
  }
  return _impl_.request_.next_;
}
inline ::remote::LookupNextRequest* InMessage::mutable_next() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::remote::LookupNextRequest* _msg = _internal_mutable_next();
  // @@protoc_insertion_point(field_mutable:remote.InMessage.next)
  return _msg;
}

// .remote.SnapshotRequest snapshot = 9;
inline bool InMessage::has_snapshot() const {
  return request_case() == kSnapshot;
}
inline bool InMessage::_internal_has_snapshot() const {
  return request_case() == kSnapshot;
}
inline void InMessage::set_has_snapshot() {
  _impl_._oneof_case_[0] = kSnapshot;
}
inline void InMessage::clear_snapshot() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (request_case() == kSnapshot) {
    if (GetArena() == nullptr) {
      delete _impl_.request_.snapshot_;
    }
    clear_has_request();
  }
}
inline ::remote::SnapshotRequest* InMessage::release_snapshot() {
  // @@protoc_insertion_point(field_release:remote.InMessage.snapshot)
  if (request_case() == kSnapshot) {
    clear_has_request();
    auto* temp = _impl_.request_.snapshot_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_.snapshot_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::remote::SnapshotRequest& InMessage::_internal_snapshot() const {
  return request_case() == kSnapshot ? *_impl_.request_.snapshot_ : reinterpret_cast<::remote::SnapshotRequest&>(::remote::_SnapshotRequest_default_instance_);
}
inline const ::remote::SnapshotRequest& InMessage::snapshot() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:remote.InMessage.snapshot)
  return _internal_snapshot();
}
inline ::remote::SnapshotRequest* InMessage::unsafe_arena_release_snapshot() {
  // @@protoc_insertion_point(field_unsafe_arena_release:remote.InMessage.snapshot)
  if (request_case() == kSnapshot) {
    clear_has_request();
    auto* temp = _impl_.request_.snapshot_;
    _impl_.request_.snapshot_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InMessage::unsafe_arena_set_allocated_snapshot(::remote::SnapshotRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request();
  if (value) {
    set_has_snapshot();
    _impl_.request_.snapshot_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:remote.InMessage.snapshot)
}
inline ::remote::SnapshotRequest* InMessage::_internal_mutable_snapshot() {
  if (request_case() != kSnapshot) {
    clear_request();
    set_has_snapshot();
    _impl_.request_.snapshot_ =
        ::google::protobuf::Message::DefaultConstruct<::remote::SnapshotRequest>(GetArena());
  }
  return _impl_.request_.snapshot_;
}
inline ::remote::SnapshotRequest* InMessage::mutable_snapshot() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::remote::SnapshotRequest* _msg = _internal_mutable_snapshot();
  // @@protoc_insertion_point(field_mutable:remote.InMessage.snapshot)
  return _msg;
}

inline bool InMessage::has_request() const {
  return request_case() != REQUEST_NOT_SET;
}
inline void InMessage::clear_has_request() {
  _impl_._oneof_case_[0] = REQUEST_NOT_SET;
}
inline InMessage::RequestCase InMessage::request_case() const {
  return InMessage::RequestCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// OutMessage

// .remote.OpenReply open = 1;
inline bool OutMessage::has_open() const {
  return reply_case() == kOpen;
}
inline bool OutMessage::_internal_has_open() const {
  return reply_case() == kOpen;
}
inline void OutMessage::set_has_open() {
  _impl_._oneof_case_[0] = kOpen;
}
inline void OutMessage::clear_open() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (reply_case() == kOpen) {
    if (GetArena() == nullptr) {
      delete _impl_.reply_.open_;
    }
    clear_has_reply();
  }
}
inline ::remote::OpenReply* OutMessage::release_open() {
  // @@protoc_insertion_point(field_release:remote.OutMessage.open)
  if (reply_case() == kOpen) {
    clear_has_reply();
    auto* temp = _impl_.reply_.open_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.reply_.open_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::remote::OpenReply& OutMessage::_internal_open() const {
  return reply_case() == kOpen ? *_impl_.reply_.open_ : reinterpret_cast<::remote::OpenReply&>(::remote::_OpenReply_default_instance_);
}
inline const ::remote::OpenReply& OutMessage::open() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:remote.OutMessage.open)
  return _internal_open();
}
inline ::remote::OpenReply* OutMessage::unsafe_arena_release_open() {
  // @@protoc_insertion_point(field_unsafe_arena_release:remote.OutMessage.open)
  if (reply_case() == kOpen) {
    clear_has_reply();
    auto* temp = _impl_.reply_.open_;
    _impl_.reply_.open_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void OutMessage::unsafe_arena_set_allocated_open(::remote::OpenReply* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_reply();
  if (value) {
    set_has_open();
    _impl_.reply_.open_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:remote.OutMessage.open)
}
inline ::remote::OpenReply* OutMessage::_internal_mutable_open() {
  if (reply_case() != kOpen) {
    clear_reply();
    set_has_open();
    _impl_.reply_.open_ =
        ::google::protobuf::Message::DefaultConstruct<::remote::OpenReply>(GetArena());
  }
  return _impl_.reply_.open_;
}
inline ::remote::OpenReply* OutMessage::mutable_open() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::remote::OpenReply* _msg = _internal_mutable_open();
  // @@protoc_insertion_point(field_mutable:remote.OutMessage.open)
  return _msg;
}

// .remote.CloseReply close = 3;
inline bool OutMessage::has_close() const {
  return reply_case() == kClose;
}
inline bool OutMessage::_internal_has_close() const {
  return reply_case() == kClose;
}
inline void OutMessage::set_has_close() {
  _impl_._oneof_case_[0] = kClose;
}
inline void OutMessage::clear_close() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (reply_case() == kClose) {
    if (GetArena() == nullptr) {
      delete _impl_.reply_.close_;
    }
    clear_has_reply();
  }
}
inline ::remote::CloseReply* OutMessage::release_close() {
  // @@protoc_insertion_point(field_release:remote.OutMessage.close)
  if (reply_case() == kClose) {
    clear_has_reply();
    auto* temp = _impl_.reply_.close_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.reply_.close_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::remote::CloseReply& OutMessage::_internal_close() const {
  return reply_case() == kClose ? *_impl_.reply_.close_ : reinterpret_cast<::remote::CloseReply&>(::remote::_CloseReply_default_instance_);
}
inline const ::remote::CloseReply& OutMessage::close() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:remote.OutMessage.close)
  return _internal_close();
}
inline ::remote::CloseReply* OutMessage::unsafe_arena_release_close() {
  // @@protoc_insertion_point(field_unsafe_arena_release:remote.OutMessage.close)
  if (reply_case() == kClose) {
    clear_has_reply();
    auto* temp = _impl_.reply_.close_;
    _impl_.reply_.close_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void OutMessage::unsafe_arena_set_allocated_close(::remote::CloseReply* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_reply();
  if (value) {
    set_has_close();
    _impl_.reply_.close_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:remote.OutMessage.close)
}
inline ::remote::CloseReply* OutMessage::_internal_mutable_close() {
  if (reply_case() != kClose) {
    clear_reply();
    set_has_close();
    _impl_.reply_.close_ =
        ::google::protobuf::Message::DefaultConstruct<::remote::CloseReply>(GetArena());
  }
  return _impl_.reply_.close_;
}
inline ::remote::CloseReply* OutMessage::mutable_close() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::remote::CloseReply* _msg = _internal_mutable_close();
  // @@protoc_insertion_point(field_mutable:remote.OutMessage.close)
  return _msg;
}

// .remote.GetReply get = 4;
inline bool OutMessage::has_get() const {
  return reply_case() == kGet;
}
inline bool OutMessage::_internal_has_get() const {
  return reply_case() == kGet;
}
inline void OutMessage::set_has_get() {
  _impl_._oneof_case_[0] = kGet;
}
inline void OutMessage::clear_get() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (reply_case() == kGet) {
    if (GetArena() == nullptr) {
      delete _impl_.reply_.get_;
    }
    clear_has_reply();
  }
}
inline ::remote::GetReply* OutMessage::release_get() {
  // @@protoc_insertion_point(field_release:remote.OutMessage.get)
  if (reply_case() == kGet) {
    clear_has_reply();
    auto* temp = _impl_.reply_.get_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.reply_.get_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::remote::GetReply& OutMessage::_internal_get() const {
  return reply_case() == kGet ? *_impl_.reply_.get_ : reinterpret_cast<::remote::GetReply&>(::remote::_GetReply_default_instance_);
}
inline const ::remote::GetReply& OutMessage::get() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:remote.OutMessage.get)
  return _internal_get();
}
inline ::remote::GetReply* OutMessage::unsafe_arena_release_get() {
  // @@protoc_insertion_point(field_unsafe_arena_release:remote.OutMessage.get)
  if (reply_case() == kGet) {
    clear_has_reply();
    auto* temp = _impl_.reply_.get_;
    _impl_.reply_.get_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void OutMessage::unsafe_arena_set_allocated_get(::remote::GetReply* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_reply();
  if (value) {
    set_has_get();
    _impl_.reply_.get_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:remote.OutMessage.get)
}
inline ::remote::GetReply* OutMessage::_internal_mutable_get() {
  if (reply_case() != kGet) {
    clear_reply();
    set_has_get();
    _impl_.reply_.get_ =
        ::google::protobuf::Message::DefaultConstruct<::remote::GetReply>(GetArena());
  }
  return _impl_.reply_.get_;
}
inline ::remote::GetReply* OutMessage::mutable_get() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::remote::GetReply* _msg = _internal_mutable_get();
  // @@protoc_insertion_point(field_mutable:remote.OutMessage.get)
  return _msg;
}

// .remote.PutReply put = 5;
inline bool OutMessage::has_put() const {
  return reply_case() == kPut;
}
inline bool OutMessage::_internal_has_put() const {
  return reply_case() == kPut;
}
inline void OutMessage::set_has_put() {
  _impl_._oneof_case_[0] = kPut;
}
inline void OutMessage::clear_put() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (reply_case() == kPut) {
    if (GetArena() == nullptr) {
      delete _impl_.reply_.put_;
    }
    clear_has_reply();
  }
}
inline ::remote::PutReply* OutMessage::release_put() {
  // @@protoc_insertion_point(field_release:remote.OutMessage.put)
  if (reply_case() == kPut) {
    clear_has_reply();
    auto* temp = _impl_.reply_.put_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.reply_.put_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::remote::PutReply& OutMessage::_internal_put() const {
  return reply_case() == kPut ? *_impl_.reply_.put_ : reinterpret_cast<::remote::PutReply&>(::remote::_PutReply_default_instance_);
}
inline const ::remote::PutReply& OutMessage::put() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:remote.OutMessage.put)
  return _internal_put();
}
inline ::remote::PutReply* OutMessage::unsafe_arena_release_put() {
  // @@protoc_insertion_point(field_unsafe_arena_release:remote.OutMessage.put)
  if (reply_case() == kPut) {
    clear_has_reply();
    auto* temp = _impl_.reply_.put_;
    _impl_.reply_.put_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void OutMessage::unsafe_arena_set_allocated_put(::remote::PutReply* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_reply();
  if (value) {
    set_has_put();
    _impl_.reply_.put_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:remote.OutMessage.put)
}
inline ::remote::PutReply* OutMessage::_internal_mutable_put() {
  if (reply_case() != kPut) {
    clear_reply();
    set_has_put();
    _impl_.reply_.put_ =
        ::google::protobuf::Message::DefaultConstruct<::remote::PutReply>(GetArena());
  }
  return _impl_.reply_.put_;
}
inline ::remote::PutReply* OutMessage::mutable_put() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::remote::PutReply* _msg = _internal_mutable_put();
  // @@protoc_insertion_point(field_mutable:remote.OutMessage.put)
  return _msg;
}

// .remote.WriteReply write = 6;
inline bool OutMessage::has_write() const {
  return reply_case() == kWrite;
}
inline bool OutMessage::_internal_has_write() const {
  return reply_case() == kWrite;
}
inline void OutMessage::set_has_write() {
  _impl_._oneof_case_[0] = kWrite;
}
inline void OutMessage::clear_write() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (reply_case() == kWrite) {
    if (GetArena() == nullptr) {
      delete _impl_.reply_.write_;
    }
    clear_has_reply();
  }
}
inline ::remote::WriteReply* OutMessage::release_write() {
  // @@protoc_insertion_point(field_release:remote.OutMessage.write)
  if (reply_case() == kWrite) {
    clear_has_reply();
    auto* temp = _impl_.reply_.write_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.reply_.write_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::remote::WriteReply& OutMessage::_internal_write() const {
  return reply_case() == kWrite ? *_impl_.reply_.write_ : reinterpret_cast<::remote::WriteReply&>(::remote::_WriteReply_default_instance_);
}
inline const ::remote::WriteReply& OutMessage::write() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:remote.OutMessage.write)
  return _internal_write();
}
inline ::remote::WriteReply* OutMessage::unsafe_arena_release_write() {
  // @@protoc_insertion_point(field_unsafe_arena_release:remote.OutMessage.write)
  if (reply_case() == kWrite) {
    clear_has_reply();
    auto* temp = _impl_.reply_.write_;
    _impl_.reply_.write_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void OutMessage::unsafe_arena_set_allocated_write(::remote::WriteReply* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_reply();
  if (value) {
    set_has_write();
    _impl_.reply_.write_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:remote.OutMessage.write)
}
inline ::remote::WriteReply* OutMessage::_internal_mutable_write() {
  if (reply_case() != kWrite) {
    clear_reply();
    set_has_write();
    _impl_.reply_.write_ =
        ::google::protobuf::Message::DefaultConstruct<::remote::WriteReply>(GetArena());
  }
  return _impl_.reply_.write_;
}
inline ::remote::WriteReply* OutMessage::mutable_write() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::remote::WriteReply* _msg = _internal_mutable_write();
  // @@protoc_insertion_point(field_mutable:remote.OutMessage.write)
  return _msg;
}

// .remote.LookupReply lookup = 7;
inline bool OutMessage::has_lookup() const {
  return reply_case() == kLookup;
}
inline bool OutMessage::_internal_has_lookup() const {
  return reply_case() == kLookup;
}
inline void OutMessage::set_has_lookup() {
  _impl_._oneof_case_[0] = kLookup;
}
inline void OutMessage::clear_lookup() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (reply_case() == kLookup) {
    if (GetArena() == nullptr) {
      delete _impl_.reply_.lookup_;
    }
    clear_has_reply();
  }
}
inline ::remote::LookupReply* OutMessage::release_lookup() {
  // @@protoc_insertion_point(field_release:remote.OutMessage.lookup)
  if (reply_case() == kLookup) {
    clear_has_reply();
    auto* temp = _impl_.reply_.lookup_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.reply_.lookup_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::remote::LookupReply& OutMessage::_internal_lookup() const {
  return reply_case() == kLookup ? *_impl_.reply_.lookup_ : reinterpret_cast<::remote::LookupReply&>(::remote::_LookupReply_default_instance_);
}
inline const ::remote::LookupReply& OutMessage::lookup() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:remote.OutMessage.lookup)
  return _internal_lookup();
}
inline ::remote::LookupReply* OutMessage::unsafe_arena_release_lookup() {
  // @@protoc_insertion_point(field_unsafe_arena_release:remote.OutMessage.lookup)
  if (reply_case() == kLookup) {
    clear_has_reply();
    auto* temp = _impl_.reply_.lookup_;
    _impl_.reply_.lookup_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void OutMessage::unsafe_arena_set_allocated_lookup(::remote::LookupReply* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_reply();
  if (value) {
    set_has_lookup();
    _impl_.reply_.lookup_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:remote.OutMessage.lookup)
}
inline ::remote::LookupReply* OutMessage::_internal_mutable_lookup() {
  if (reply_case() != kLookup) {
    clear_reply();
    set_has_lookup();
    _impl_.reply_.lookup_ =
        ::google::protobuf::Message::DefaultConstruct<::remote::LookupReply>(GetArena());
  }
  return _impl_.reply_.lookup_;
}
inline ::remote::LookupReply* OutMessage::mutable_lookup() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::remote::LookupReply* _msg = _internal_mutable_lookup();
  // @@protoc_insertion_point(field_mutable:remote.OutMessage.lookup)
  return _msg;
}

// .remote.LookupNextReply next = 8;
inline bool OutMessage::has_next() const {
  return reply_case() == kNext;
}
inline bool OutMessage::_internal_has_next() const {
  return reply_case() == kNext;
}
inline void OutMessage::set_has_next() {
  _impl_._oneof_case_[0] = kNext;
}
inline void OutMessage::clear_next() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (reply_case() == kNext) {
    if (GetArena() == nullptr) {
      delete _impl_.reply_.next_;
    }
    clear_has_reply();
  }
}
inline ::remote::LookupNextReply* OutMessage::release_next() {
  // @@protoc_insertion_point(field_release:remote.OutMessage.next)
  if (reply_case() == kNext) {
    clear_has_reply();
    auto* temp = _impl_.reply_.next_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.reply_.next_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::remote::LookupNextReply& OutMessage::_internal_next() const {
  return reply_case() == kNext ? *_impl_.reply_.next_ : reinterpret_cast<::remote::LookupNextReply&>(::remote::_LookupNextReply_default_instance_);
}
inline const ::remote::LookupNextReply& OutMessage::next() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:remote.OutMessage.next)
  return _internal_next();
}
inline ::remote::LookupNextReply* OutMessage::unsafe_arena_release_next() {
  // @@protoc_insertion_point(field_unsafe_arena_release:remote.OutMessage.next)
  if (reply_case() == kNext) {
    clear_has_reply();
    auto* temp = _impl_.reply_.next_;
    _impl_.reply_.next_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void OutMessage::unsafe_arena_set_allocated_next(::remote::LookupNextReply* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_reply();
  if (value) {
    set_has_next();
    _impl_.reply_.next_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:remote.OutMessage.next)
}
inline ::remote::LookupNextReply* OutMessage::_internal_mutable_next() {
  if (reply_case() != kNext) {
    clear_reply();
    set_has_next();
    _impl_.reply_.next_ =
        ::google::protobuf::Message::DefaultConstruct<::remote::LookupNextReply>(GetArena());
  }
  return _impl_.reply_.next_;
}
inline ::remote::LookupNextReply* OutMessage::mutable_next() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::remote::LookupNextReply* _msg = _internal_mutable_next();
  // @@protoc_insertion_point(field_mutable:remote.OutMessage.next)
  return _msg;
}

// .remote.SnapshotReply snapshot = 9;
inline bool OutMessage::has_snapshot() const {
  return reply_case() == kSnapshot;
}
inline bool OutMessage::_internal_has_snapshot() const {
  return reply_case() == kSnapshot;
}
inline void OutMessage::set_has_snapshot() {
  _impl_._oneof_case_[0] = kSnapshot;
}
inline void OutMessage::clear_snapshot() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (reply_case() == kSnapshot) {
    if (GetArena() == nullptr) {
      delete _impl_.reply_.snapshot_;
    }
    clear_has_reply();
  }
}
inline ::remote::SnapshotReply* OutMessage::release_snapshot() {
  // @@protoc_insertion_point(field_release:remote.OutMessage.snapshot)
  if (reply_case() == kSnapshot) {
    clear_has_reply();
    auto* temp = _impl_.reply_.snapshot_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.reply_.snapshot_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::remote::SnapshotReply& OutMessage::_internal_snapshot() const {
  return reply_case() == kSnapshot ? *_impl_.reply_.snapshot_ : reinterpret_cast<::remote::SnapshotReply&>(::remote::_SnapshotReply_default_instance_);
}
inline const ::remote::SnapshotReply& OutMessage::snapshot() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:remote.OutMessage.snapshot)
  return _internal_snapshot();
}
inline ::remote::SnapshotReply* OutMessage::unsafe_arena_release_snapshot() {
  // @@protoc_insertion_point(field_unsafe_arena_release:remote.OutMessage.snapshot)
  if (reply_case() == kSnapshot) {
    clear_has_reply();
    auto* temp = _impl_.reply_.snapshot_;
    _impl_.reply_.snapshot_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void OutMessage::unsafe_arena_set_allocated_snapshot(::remote::SnapshotReply* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_reply();
  if (value) {
    set_has_snapshot();
    _impl_.reply_.snapshot_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:remote.OutMessage.snapshot)
}
inline ::remote::SnapshotReply* OutMessage::_internal_mutable_snapshot() {
  if (reply_case() != kSnapshot) {
    clear_reply();
    set_has_snapshot();
    _impl_.reply_.snapshot_ =
        ::google::protobuf::Message::DefaultConstruct<::remote::SnapshotReply>(GetArena());
  }
  return _impl_.reply_.snapshot_;
}
inline ::remote::SnapshotReply* OutMessage::mutable_snapshot() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::remote::SnapshotReply* _msg = _internal_mutable_snapshot();
  // @@protoc_insertion_point(field_mutable:remote.OutMessage.snapshot)
  return _msg;
}

inline bool OutMessage::has_reply() const {
  return reply_case() != REPLY_NOT_SET;
}
inline void OutMessage::clear_has_reply() {
  _impl_._oneof_case_[0] = REPLY_NOT_SET;
}
inline OutMessage::ReplyCase OutMessage::reply_case() const {
  return OutMessage::ReplyCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// OpenRequest

// string dbname = 1;
inline void OpenRequest::clear_dbname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dbname_.ClearToEmpty();
}
inline const std::string& OpenRequest::dbname() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:remote.OpenRequest.dbname)
  return _internal_dbname();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OpenRequest::set_dbname(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dbname_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:remote.OpenRequest.dbname)
}
inline std::string* OpenRequest::mutable_dbname() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_dbname();
  // @@protoc_insertion_point(field_mutable:remote.OpenRequest.dbname)
  return _s;
}
inline const std::string& OpenRequest::_internal_dbname() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dbname_.Get();
}
inline void OpenRequest::_internal_set_dbname(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dbname_.Set(value, GetArena());
}
inline std::string* OpenRequest::_internal_mutable_dbname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.dbname_.Mutable( GetArena());
}
inline std::string* OpenRequest::release_dbname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:remote.OpenRequest.dbname)
  return _impl_.dbname_.Release();
}
inline void OpenRequest::set_allocated_dbname(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dbname_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.dbname_.IsDefault()) {
          _impl_.dbname_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:remote.OpenRequest.dbname)
}

// bool create = 2;
inline void OpenRequest::clear_create() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.create_ = false;
}
inline bool OpenRequest::create() const {
  // @@protoc_insertion_point(field_get:remote.OpenRequest.create)
  return _internal_create();
}
inline void OpenRequest::set_create(bool value) {
  _internal_set_create(value);
  // @@protoc_insertion_point(field_set:remote.OpenRequest.create)
}
inline bool OpenRequest::_internal_create() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.create_;
}
inline void OpenRequest::_internal_set_create(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.create_ = value;
}

// -------------------------------------------------------------------

// OpenReply

// string error = 2;
inline void OpenReply::clear_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_.ClearToEmpty();
}
inline const std::string& OpenReply::error() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:remote.OpenReply.error)
  return _internal_error();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OpenReply::set_error(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:remote.OpenReply.error)
}
inline std::string* OpenReply::mutable_error() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:remote.OpenReply.error)
  return _s;
}
inline const std::string& OpenReply::_internal_error() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.error_.Get();
}
inline void OpenReply::_internal_set_error(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_.Set(value, GetArena());
}
inline std::string* OpenReply::_internal_mutable_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.error_.Mutable( GetArena());
}
inline std::string* OpenReply::release_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:remote.OpenReply.error)
  return _impl_.error_.Release();
}
inline void OpenReply::set_allocated_error(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.error_.IsDefault()) {
          _impl_.error_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:remote.OpenReply.error)
}

// -------------------------------------------------------------------

// RemoveRequest

// string dbname = 1;
inline void RemoveRequest::clear_dbname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dbname_.ClearToEmpty();
}
inline const std::string& RemoveRequest::dbname() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:remote.RemoveRequest.dbname)
  return _internal_dbname();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RemoveRequest::set_dbname(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dbname_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:remote.RemoveRequest.dbname)
}
inline std::string* RemoveRequest::mutable_dbname() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_dbname();
  // @@protoc_insertion_point(field_mutable:remote.RemoveRequest.dbname)
  return _s;
}
inline const std::string& RemoveRequest::_internal_dbname() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dbname_.Get();
}
inline void RemoveRequest::_internal_set_dbname(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dbname_.Set(value, GetArena());
}
inline std::string* RemoveRequest::_internal_mutable_dbname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.dbname_.Mutable( GetArena());
}
inline std::string* RemoveRequest::release_dbname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:remote.RemoveRequest.dbname)
  return _impl_.dbname_.Release();
}
inline void RemoveRequest::set_allocated_dbname(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dbname_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.dbname_.IsDefault()) {
          _impl_.dbname_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:remote.RemoveRequest.dbname)
}

// -------------------------------------------------------------------

// RemoveReply

// string error = 1;
inline void RemoveReply::clear_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_.ClearToEmpty();
}
inline const std::string& RemoveReply::error() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:remote.RemoveReply.error)
  return _internal_error();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RemoveReply::set_error(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:remote.RemoveReply.error)
}
inline std::string* RemoveReply::mutable_error() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:remote.RemoveReply.error)
  return _s;
}
inline const std::string& RemoveReply::_internal_error() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.error_.Get();
}
inline void RemoveReply::_internal_set_error(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_.Set(value, GetArena());
}
inline std::string* RemoveReply::_internal_mutable_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.error_.Mutable( GetArena());
}
inline std::string* RemoveReply::release_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:remote.RemoveReply.error)
  return _impl_.error_.Release();
}
inline void RemoveReply::set_allocated_error(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.error_.IsDefault()) {
          _impl_.error_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:remote.RemoveReply.error)
}

// -------------------------------------------------------------------

// CloseRequest

// -------------------------------------------------------------------

// CloseReply

// string error = 1;
inline void CloseReply::clear_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_.ClearToEmpty();
}
inline const std::string& CloseReply::error() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:remote.CloseReply.error)
  return _internal_error();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CloseReply::set_error(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:remote.CloseReply.error)
}
inline std::string* CloseReply::mutable_error() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:remote.CloseReply.error)
  return _s;
}
inline const std::string& CloseReply::_internal_error() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.error_.Get();
}
inline void CloseReply::_internal_set_error(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_.Set(value, GetArena());
}
inline std::string* CloseReply::_internal_mutable_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.error_.Mutable( GetArena());
}
inline std::string* CloseReply::release_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:remote.CloseReply.error)
  return _impl_.error_.Release();
}
inline void CloseReply::set_allocated_error(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.error_.IsDefault()) {
          _impl_.error_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:remote.CloseReply.error)
}

// -------------------------------------------------------------------

// GetRequest

// bytes key = 1;
inline void GetRequest::clear_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_.ClearToEmpty();
}
inline const std::string& GetRequest::key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:remote.GetRequest.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetRequest::set_key(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:remote.GetRequest.key)
}
inline std::string* GetRequest::mutable_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:remote.GetRequest.key)
  return _s;
}
inline const std::string& GetRequest::_internal_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.key_.Get();
}
inline void GetRequest::_internal_set_key(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_.Set(value, GetArena());
}
inline std::string* GetRequest::_internal_mutable_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.key_.Mutable( GetArena());
}
inline std::string* GetRequest::release_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:remote.GetRequest.key)
  return _impl_.key_.Release();
}
inline void GetRequest::set_allocated_key(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.key_.IsDefault()) {
          _impl_.key_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:remote.GetRequest.key)
}

// uint64 snapshot = 2;
inline void GetRequest::clear_snapshot() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.snapshot_ = ::uint64_t{0u};
}
inline ::uint64_t GetRequest::snapshot() const {
  // @@protoc_insertion_point(field_get:remote.GetRequest.snapshot)
  return _internal_snapshot();
}
inline void GetRequest::set_snapshot(::uint64_t value) {
  _internal_set_snapshot(value);
  // @@protoc_insertion_point(field_set:remote.GetRequest.snapshot)
}
inline ::uint64_t GetRequest::_internal_snapshot() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.snapshot_;
}
inline void GetRequest::_internal_set_snapshot(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.snapshot_ = value;
}

// -------------------------------------------------------------------

// GetReply

// bytes value = 1;
inline void GetReply::clear_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.value_.ClearToEmpty();
}
inline const std::string& GetReply::value() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:remote.GetReply.value)
  return _internal_value();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetReply::set_value(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.value_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:remote.GetReply.value)
}
inline std::string* GetReply::mutable_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:remote.GetReply.value)
  return _s;
}
inline const std::string& GetReply::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.value_.Get();
}
inline void GetReply::_internal_set_value(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.value_.Set(value, GetArena());
}
inline std::string* GetReply::_internal_mutable_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.value_.Mutable( GetArena());
}
inline std::string* GetReply::release_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:remote.GetReply.value)
  return _impl_.value_.Release();
}
inline void GetReply::set_allocated_value(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.value_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.value_.IsDefault()) {
          _impl_.value_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:remote.GetReply.value)
}

// string error = 2;
inline void GetReply::clear_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_.ClearToEmpty();
}
inline const std::string& GetReply::error() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:remote.GetReply.error)
  return _internal_error();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetReply::set_error(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:remote.GetReply.error)
}
inline std::string* GetReply::mutable_error() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:remote.GetReply.error)
  return _s;
}
inline const std::string& GetReply::_internal_error() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.error_.Get();
}
inline void GetReply::_internal_set_error(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_.Set(value, GetArena());
}
inline std::string* GetReply::_internal_mutable_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.error_.Mutable( GetArena());
}
inline std::string* GetReply::release_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:remote.GetReply.error)
  return _impl_.error_.Release();
}
inline void GetReply::set_allocated_error(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.error_.IsDefault()) {
          _impl_.error_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:remote.GetReply.error)
}

// -------------------------------------------------------------------

// PutRequest

// bytes key = 1;
inline void PutRequest::clear_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_.ClearToEmpty();
}
inline const std::string& PutRequest::key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:remote.PutRequest.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PutRequest::set_key(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:remote.PutRequest.key)
}
inline std::string* PutRequest::mutable_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:remote.PutRequest.key)
  return _s;
}
inline const std::string& PutRequest::_internal_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.key_.Get();
}
inline void PutRequest::_internal_set_key(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_.Set(value, GetArena());
}
inline std::string* PutRequest::_internal_mutable_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.key_.Mutable( GetArena());
}
inline std::string* PutRequest::release_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:remote.PutRequest.key)
  return _impl_.key_.Release();
}
inline void PutRequest::set_allocated_key(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.key_.IsDefault()) {
          _impl_.key_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:remote.PutRequest.key)
}

// bytes value = 2;
inline void PutRequest::clear_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.value_.ClearToEmpty();
}
inline const std::string& PutRequest::value() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:remote.PutRequest.value)
  return _internal_value();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PutRequest::set_value(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.value_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:remote.PutRequest.value)
}
inline std::string* PutRequest::mutable_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:remote.PutRequest.value)
  return _s;
}
inline const std::string& PutRequest::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.value_.Get();
}
inline void PutRequest::_internal_set_value(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.value_.Set(value, GetArena());
}
inline std::string* PutRequest::_internal_mutable_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.value_.Mutable( GetArena());
}
inline std::string* PutRequest::release_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:remote.PutRequest.value)
  return _impl_.value_.Release();
}
inline void PutRequest::set_allocated_value(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.value_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.value_.IsDefault()) {
          _impl_.value_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:remote.PutRequest.value)
}

// -------------------------------------------------------------------

// PutReply

// string error = 1;
inline void PutReply::clear_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_.ClearToEmpty();
}
inline const std::string& PutReply::error() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:remote.PutReply.error)
  return _internal_error();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PutReply::set_error(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:remote.PutReply.error)
}
inline std::string* PutReply::mutable_error() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:remote.PutReply.error)
  return _s;
}
inline const std::string& PutReply::_internal_error() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.error_.Get();
}
inline void PutReply::_internal_set_error(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_.Set(value, GetArena());
}
inline std::string* PutReply::_internal_mutable_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.error_.Mutable( GetArena());
}
inline std::string* PutReply::release_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:remote.PutReply.error)
  return _impl_.error_.Release();
}
inline void PutReply::set_allocated_error(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.error_.IsDefault()) {
          _impl_.error_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:remote.PutReply.error)
}

// -------------------------------------------------------------------

// WriteRequest

// repeated .remote.KeyValue entries = 1;
inline int WriteRequest::_internal_entries_size() const {
  return _internal_entries().size();
}
inline int WriteRequest::entries_size() const {
  return _internal_entries_size();
}
inline void WriteRequest::clear_entries() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.entries_.Clear();
}
inline ::remote::KeyValue* WriteRequest::mutable_entries(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:remote.WriteRequest.entries)
  return _internal_mutable_entries()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::remote::KeyValue>* WriteRequest::mutable_entries()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:remote.WriteRequest.entries)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_entries();
}
inline const ::remote::KeyValue& WriteRequest::entries(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:remote.WriteRequest.entries)
  return _internal_entries().Get(index);
}
inline ::remote::KeyValue* WriteRequest::add_entries() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::remote::KeyValue* _add = _internal_mutable_entries()->Add();
  // @@protoc_insertion_point(field_add:remote.WriteRequest.entries)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::remote::KeyValue>& WriteRequest::entries() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:remote.WriteRequest.entries)
  return _internal_entries();
}
inline const ::google::protobuf::RepeatedPtrField<::remote::KeyValue>&
WriteRequest::_internal_entries() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.entries_;
}
inline ::google::protobuf::RepeatedPtrField<::remote::KeyValue>*
WriteRequest::_internal_mutable_entries() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.entries_;
}

// -------------------------------------------------------------------

// WriteReply

// string error = 1;
inline void WriteReply::clear_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_.ClearToEmpty();
}
inline const std::string& WriteReply::error() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:remote.WriteReply.error)
  return _internal_error();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void WriteReply::set_error(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:remote.WriteReply.error)
}
inline std::string* WriteReply::mutable_error() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:remote.WriteReply.error)
  return _s;
}
inline const std::string& WriteReply::_internal_error() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.error_.Get();
}
inline void WriteReply::_internal_set_error(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_.Set(value, GetArena());
}
inline std::string* WriteReply::_internal_mutable_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.error_.Mutable( GetArena());
}
inline std::string* WriteReply::release_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:remote.WriteReply.error)
  return _impl_.error_.Release();
}
inline void WriteReply::set_allocated_error(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.error_.IsDefault()) {
          _impl_.error_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:remote.WriteReply.error)
}

// -------------------------------------------------------------------

// LookupRequest

// bytes lower = 1;
inline void LookupRequest::clear_lower() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.lower_.ClearToEmpty();
}
inline const std::string& LookupRequest::lower() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:remote.LookupRequest.lower)
  return _internal_lower();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LookupRequest::set_lower(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.lower_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:remote.LookupRequest.lower)
}
inline std::string* LookupRequest::mutable_lower() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_lower();
  // @@protoc_insertion_point(field_mutable:remote.LookupRequest.lower)
  return _s;
}
inline const std::string& LookupRequest::_internal_lower() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.lower_.Get();
}
inline void LookupRequest::_internal_set_lower(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.lower_.Set(value, GetArena());
}
inline std::string* LookupRequest::_internal_mutable_lower() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.lower_.Mutable( GetArena());
}
inline std::string* LookupRequest::release_lower() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:remote.LookupRequest.lower)
  return _impl_.lower_.Release();
}
inline void LookupRequest::set_allocated_lower(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.lower_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.lower_.IsDefault()) {
          _impl_.lower_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:remote.LookupRequest.lower)
}

// bytes upper = 2;
inline void LookupRequest::clear_upper() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.upper_.ClearToEmpty();
}
inline const std::string& LookupRequest::upper() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:remote.LookupRequest.upper)
  return _internal_upper();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LookupRequest::set_upper(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.upper_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:remote.LookupRequest.upper)
}
inline std::string* LookupRequest::mutable_upper() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_upper();
  // @@protoc_insertion_point(field_mutable:remote.LookupRequest.upper)
  return _s;
}
inline const std::string& LookupRequest::_internal_upper() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.upper_.Get();
}
inline void LookupRequest::_internal_set_upper(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.upper_.Set(value, GetArena());
}
inline std::string* LookupRequest::_internal_mutable_upper() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.upper_.Mutable( GetArena());
}
inline std::string* LookupRequest::release_upper() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:remote.LookupRequest.upper)
  return _impl_.upper_.Release();
}
inline void LookupRequest::set_allocated_upper(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.upper_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.upper_.IsDefault()) {
          _impl_.upper_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:remote.LookupRequest.upper)
}

// uint64 snapshot = 3;
inline void LookupRequest::clear_snapshot() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.snapshot_ = ::uint64_t{0u};
}
inline ::uint64_t LookupRequest::snapshot() const {
  // @@protoc_insertion_point(field_get:remote.LookupRequest.snapshot)
  return _internal_snapshot();
}
inline void LookupRequest::set_snapshot(::uint64_t value) {
  _internal_set_snapshot(value);
  // @@protoc_insertion_point(field_set:remote.LookupRequest.snapshot)
}
inline ::uint64_t LookupRequest::_internal_snapshot() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.snapshot_;
}
inline void LookupRequest::_internal_set_snapshot(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.snapshot_ = value;
}

// -------------------------------------------------------------------

// LookupReply

// uint64 id = 1;
inline void LookupReply::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = ::uint64_t{0u};
}
inline ::uint64_t LookupReply::id() const {
  // @@protoc_insertion_point(field_get:remote.LookupReply.id)
  return _internal_id();
}
inline void LookupReply::set_id(::uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:remote.LookupReply.id)
}
inline ::uint64_t LookupReply::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void LookupReply::_internal_set_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = value;
}

// string error = 2;
inline void LookupReply::clear_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_.ClearToEmpty();
}
inline const std::string& LookupReply::error() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:remote.LookupReply.error)
  return _internal_error();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LookupReply::set_error(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:remote.LookupReply.error)
}
inline std::string* LookupReply::mutable_error() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:remote.LookupReply.error)
  return _s;
}
inline const std::string& LookupReply::_internal_error() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.error_.Get();
}
inline void LookupReply::_internal_set_error(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_.Set(value, GetArena());
}
inline std::string* LookupReply::_internal_mutable_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.error_.Mutable( GetArena());
}
inline std::string* LookupReply::release_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:remote.LookupReply.error)
  return _impl_.error_.Release();
}
inline void LookupReply::set_allocated_error(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.error_.IsDefault()) {
          _impl_.error_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:remote.LookupReply.error)
}

// -------------------------------------------------------------------

// LookupNextRequest

// uint64 id = 1;
inline void LookupNextRequest::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = ::uint64_t{0u};
}
inline ::uint64_t LookupNextRequest::id() const {
  // @@protoc_insertion_point(field_get:remote.LookupNextRequest.id)
  return _internal_id();
}
inline void LookupNextRequest::set_id(::uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:remote.LookupNextRequest.id)
}
inline ::uint64_t LookupNextRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void LookupNextRequest::_internal_set_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = value;
}

// -------------------------------------------------------------------

// KeyValue

// bytes key = 1;
inline void KeyValue::clear_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_.ClearToEmpty();
}
inline const std::string& KeyValue::key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:remote.KeyValue.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void KeyValue::set_key(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:remote.KeyValue.key)
}
inline std::string* KeyValue::mutable_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:remote.KeyValue.key)
  return _s;
}
inline const std::string& KeyValue::_internal_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.key_.Get();
}
inline void KeyValue::_internal_set_key(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_.Set(value, GetArena());
}
inline std::string* KeyValue::_internal_mutable_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.key_.Mutable( GetArena());
}
inline std::string* KeyValue::release_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:remote.KeyValue.key)
  return _impl_.key_.Release();
}
inline void KeyValue::set_allocated_key(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.key_.IsDefault()) {
          _impl_.key_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:remote.KeyValue.key)
}

// bytes value = 2;
inline void KeyValue::clear_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.value_.ClearToEmpty();
}
inline const std::string& KeyValue::value() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:remote.KeyValue.value)
  return _internal_value();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void KeyValue::set_value(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.value_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:remote.KeyValue.value)
}
inline std::string* KeyValue::mutable_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:remote.KeyValue.value)
  return _s;
}
inline const std::string& KeyValue::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.value_.Get();
}
inline void KeyValue::_internal_set_value(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.value_.Set(value, GetArena());
}
inline std::string* KeyValue::_internal_mutable_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.value_.Mutable( GetArena());
}
inline std::string* KeyValue::release_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:remote.KeyValue.value)
  return _impl_.value_.Release();
}
inline void KeyValue::set_allocated_value(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.value_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.value_.IsDefault()) {
          _impl_.value_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:remote.KeyValue.value)
}

// -------------------------------------------------------------------

// LookupNextReply

// repeated .remote.KeyValue entries = 1;
inline int LookupNextReply::_internal_entries_size() const {
  return _internal_entries().size();
}
inline int LookupNextReply::entries_size() const {
  return _internal_entries_size();
}
inline void LookupNextReply::clear_entries() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.entries_.Clear();
}
inline ::remote::KeyValue* LookupNextReply::mutable_entries(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:remote.LookupNextReply.entries)
  return _internal_mutable_entries()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::remote::KeyValue>* LookupNextReply::mutable_entries()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:remote.LookupNextReply.entries)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_entries();
}
inline const ::remote::KeyValue& LookupNextReply::entries(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:remote.LookupNextReply.entries)
  return _internal_entries().Get(index);
}
inline ::remote::KeyValue* LookupNextReply::add_entries() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::remote::KeyValue* _add = _internal_mutable_entries()->Add();
  // @@protoc_insertion_point(field_add:remote.LookupNextReply.entries)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::remote::KeyValue>& LookupNextReply::entries() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:remote.LookupNextReply.entries)
  return _internal_entries();
}
inline const ::google::protobuf::RepeatedPtrField<::remote::KeyValue>&
LookupNextReply::_internal_entries() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.entries_;
}
inline ::google::protobuf::RepeatedPtrField<::remote::KeyValue>*
LookupNextReply::_internal_mutable_entries() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.entries_;
}

// string error = 2;
inline void LookupNextReply::clear_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_.ClearToEmpty();
}
inline const std::string& LookupNextReply::error() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:remote.LookupNextReply.error)
  return _internal_error();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LookupNextReply::set_error(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:remote.LookupNextReply.error)
}
inline std::string* LookupNextReply::mutable_error() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:remote.LookupNextReply.error)
  return _s;
}
inline const std::string& LookupNextReply::_internal_error() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.error_.Get();
}
inline void LookupNextReply::_internal_set_error(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_.Set(value, GetArena());
}
inline std::string* LookupNextReply::_internal_mutable_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.error_.Mutable( GetArena());
}
inline std::string* LookupNextReply::release_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:remote.LookupNextReply.error)
  return _impl_.error_.Release();
}
inline void LookupNextReply::set_allocated_error(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.error_.IsDefault()) {
          _impl_.error_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:remote.LookupNextReply.error)
}

// -------------------------------------------------------------------

// SnapshotRequest

// -------------------------------------------------------------------

// SnapshotReply

// uint64 id = 1;
inline void SnapshotReply::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = ::uint64_t{0u};
}
inline ::uint64_t SnapshotReply::id() const {
  // @@protoc_insertion_point(field_get:remote.SnapshotReply.id)
  return _internal_id();
}
inline void SnapshotReply::set_id(::uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:remote.SnapshotReply.id)
}
inline ::uint64_t SnapshotReply::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void SnapshotReply::_internal_set_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = value;
}

// string error = 2;
inline void SnapshotReply::clear_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_.ClearToEmpty();
}
inline const std::string& SnapshotReply::error() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:remote.SnapshotReply.error)
  return _internal_error();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SnapshotReply::set_error(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:remote.SnapshotReply.error)
}
inline std::string* SnapshotReply::mutable_error() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:remote.SnapshotReply.error)
  return _s;
}
inline const std::string& SnapshotReply::_internal_error() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.error_.Get();
}
inline void SnapshotReply::_internal_set_error(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_.Set(value, GetArena());
}
inline std::string* SnapshotReply::_internal_mutable_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.error_.Mutable( GetArena());
}
inline std::string* SnapshotReply::release_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:remote.SnapshotReply.error)
  return _impl_.error_.Release();
}
inline void SnapshotReply::set_allocated_error(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.error_.IsDefault()) {
          _impl_.error_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:remote.SnapshotReply.error)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace remote


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_leveldbr_2eproto_2epb_2eh
